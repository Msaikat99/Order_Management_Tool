<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Order Tools</title>
    <!-- Common Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <style>
        /* Global CSS Variables for Theming */
        :root {
          --bg-color: #f0f2f5; /* Lighter, modern background */
          --container-bg: #ffffff; /* Crisp white for containers */
          --text-color: #333d4d; /* Darker, more professional text */
          --light-text-color: #6a7482; /* Lighter text for secondary info */
          --header-color: #2c3e50; /* Dark blue for headers */
          --accent-color: #007bff; /* Primary accent blue */
          --card-bg: #ffffff; /* White background for cards */
          --border-color: #e0e6ed; /* Soft border color */
          --shadow-light: rgba(0, 0, 0, 0.05); /* Light shadow for subtle depth */
          --shadow-medium: rgba(0, 0, 0, 0.1); /* Medium shadow for lifted elements */
          --shadow-strong: rgba(0, 0, 0, 0.15); /* Stronger shadow on hover */

          --input-bg: #f8fafd; /* Light background for inputs */
          --input-border: #cdd5df; /* Soft border for inputs */
          --input-focus-border: var(--accent-color); /* Accent color on focus */

          --button-primary-bg: var(--accent-color);
          --button-primary-hover: #0056b3;
          --button-secondary-bg: #6c757d;
          --button-secondary-hover: #5a6268;
          --button-success-bg: #28a745;
          --button-success-hover: #218838;
          --button-danger-bg: #dc3545;
          --button-danger-hover: #c82333;

          /* Messages/Status colors */
          --processing-bg: #eaf6ff; /* Soft blue for processing */
          --error-bg: #fde8e8; /* Soft red for error */
          --error-text: #a02020;
          --success-bg: #e6faed; /* Soft green for success */
          --success-text: #28a745;
          --info-bg: #e0f2f7; /* Soft cyan for info */
          --info-text: #006080;

          /* Table specific */
          --table-header-bg: linear-gradient(135deg, #4a69bd 0%, #6a89cc 100%); /* Blue gradient for headers */
          --table-header-text: #ffffff;
          --table-even-row: #f9fbfd; /* Very light subtle stripe */
          --table-hover-row: #f0f4f7; /* Slightly darker hover */
          --table-border-inner: #eceff4; /* Lighter inner borders */
          --table-border-outer: var(--border-color);

          /* Highlighted table cells */
          --highlight-gradient-start: #e0f2f7; /* Light blue */
          --highlight-gradient-end: #cce7ff; /* Slightly darker light blue */
          --highlight-text-color: var(--text-color); /* Default text color */

          /* Top Performer specific colors */
          --performer-1-bg: linear-gradient(135deg, #28a745 0%, #218838 100%); /* Green */
          --performer-2-bg: linear-gradient(135deg, #6fdc6f 0%, #4CAF50 100%); /* Light Green */
          --performer-3-bg: linear-gradient(135deg, #FFD700 0%, #e6be00 100%); /* Yellow (Gold) */
          --performer-4-bg: linear-gradient(135deg, #FFCC00 0%, #FF9900 100%); /* Gold/Orange-Yellow - Darkened for visibility */
          --performer-5-bg: linear-gradient(135deg, #FF9933 0%, #CC6600 100%); /* Deeper Orange - Adjusted for visibility */

          /* Individual Report specific gradient */
          --individual-report-card-bg: linear-gradient(135deg, #7F00FF 0%, #E100FF 100%); /* Purple gradient */
        }

        [data-theme="dark"] {
          --bg-color: #282c34; /* Dark charcoal background */
          --container-bg: #323842; /* Slightly lighter dark for containers */
          --text-color: #e0e6eb; /* Light gray text */
          --light-text-color: #aeb5bf;
          --header-color: #7ab2fa; /* Light blue for headers */
          --accent-color: #61afef; /* Brighter blue accent */
          --card-bg: #3a414d;
          --border-color: #4a515d;
          --shadow-light: rgba(0, 0, 0, 0.2);
          --shadow-medium: rgba(0, 0, 0, 0.35);
          --shadow-strong: rgba(0, 0, 0, 0.5);

          --input-bg: #434a54;
          --input-border: #5b636f;
          --input-focus-border: var(--accent-color);

          --button-primary-bg: #61afef;
          --button-primary-hover: #509ad0;
          --button-secondary-bg: #5c626b;
          --button-secondary-hover: #707782;
          --button-success-bg: #6a9c6a;
          --button-success-hover: #5a8a5a;
          --button-danger-bg: #e06c75;
          --button-danger-hover: #c15b63;

          --processing-bg: #2d4560;
          --error-bg: #5f3e44;
          --error-text: #ff8888;
          --success-bg: #3f5f4f;
          --success-text: #88ff88;
          --info-bg: #3a5c6b;
          --info-text: #99ccff;

          --table-header-bg: linear-gradient(135deg, #445678 0%, #556a90 100%);
          --table-header-text: #e0e6eb;
          --table-even-row: #383f4a;
          --table-hover-row: #434a54;
          --table-border-inner: #4a515d;
          --table-border-outer: #4a515d;

          --highlight-gradient-start: #4a515d; /* Darker grey */
          --highlight-gradient-end: #5b636f; /* Even darker grey */
          --highlight-text-color: var(--text-color);

          /* Top Performer specific colors for dark mode */
          --performer-1-bg: linear-gradient(135deg, #6a9c6a 0%, #5a8a5a 100%); /* Darker Green */
          --performer-2-bg: linear-gradient(135deg, #8bc34a 0%, #7cb342 100%); /* Slightly lighter Green */
          --performer-3-bg: linear-gradient(135deg, #FFEB3B 0%, #FDD835 100%); /* Lighter Yellow */
          --performer-4-bg: linear-gradient(135deg, #FFD54F 0%, #FFC107 100%); /* Amber - Darkened for visibility */
          --performer-5-bg: linear-gradient(135deg, #FFB300 0%, #FF8C00 100%); /* Darker Orange - Adjusted for visibility */

          /* Individual Report specific gradient for dark mode */
          --individual-report-card-bg: linear-gradient(135deg, #9370db 0%, #b06edb 100%); /* Lighter purple gradient for dark mode */
        }

        /* Base styles & transitions */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            transition: background-color 0.4s ease, color 0.4s ease;
            line-height: 1.6;
        }

        /* General container for startup and tools */
        .nav-buttons-container, .tool-container {
            background: var(--container-bg);
            border-radius: 12px;
            box-shadow: 0 8px 25px var(--shadow-medium);
            padding: 40px;
            max-width: 1000px;
            width: 100%;
            transition: background-color 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease;
            box-sizing: border-box; /* Include padding in width */
            margin-bottom: 20px;
            position: relative; /* Needed for absolute positioning of toggle */
        }

        .nav-buttons-container {
            text-align: center;
            display: none; /* Controlled by JS */
            flex-direction: column;
            gap: 25px; /* More space between sections */
        }

        .tool-container {
            margin-top: 0; /* Remove extra margin */
            display: none; /* Controlled by JS */
        }
        .tool-container.active {
            display: block !important;
        }

        /* Header styles */
        .app-header h1, .tool-container h1 {
            color: var(--header-color);
            font-size: 2.8em;
            margin-bottom: 10px;
            letter-spacing: -0.05em; /* Tighter letter spacing for headers */
            transition: color 0.4s ease;
            font-weight: 700; /* Bolder headers */
            padding-top: 20px; /* Add padding to prevent overlap with back/toggle buttons */
        }
        .app-header p {
            font-size: 1.1em;
            color: var(--light-text-color);
            margin-bottom: 0;
            transition: color 0.4s ease;
        }

        /* Tool selection cards */
        .tool-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 30px; /* Increased gap */
            justify-content: center;
            margin-top: 30px;
        }
        .tool-card {
            flex: 1;
            min-width: 320px; /* Min width for responsiveness */
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px; /* More padding */
            box-shadow: 0 4px 15px var(--shadow-light); /* Softer initial shadow */
            text-align: left;
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        }
        .tool-card:hover {
            transform: translateY(-8px); /* More pronounced lift */
            box-shadow: 0 12px 30px var(--shadow-strong); /* Stronger shadow on hover */
        }
        .tool-card h2 {
            font-size: 2em; /* Larger card titles */
            color: var(--accent-color);
            margin-bottom: 18px;
            font-weight: 600;
        }
        .tool-card ul {
            list-style: none;
            padding: 0;
            margin-bottom: 25px;
        }
        .tool-card ul li {
            margin-bottom: 10px;
            color: var(--text-color);
            display: flex;
            align-items: flex-start; /* Align text to top if multiline */
            font-size: 0.95em;
        }
        .tool-card ul li::before {
            content: '✓'; /* Modern checkmark */
            color: var(--button-success-bg); /* Green checkmark */
            font-weight: bold;
            display: inline-block;
            width: 1.2em;
            margin-left: -1.2em;
            flex-shrink: 0; /* Prevent checkmark from shrinking */
            padding-right: 5px;
        }

        /* Buttons */
        button, .summary-tool button:not(.back-to-options-btn), .validator-tool button:not(.back-to-options-btn) {
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            border-radius: 8px; /* Consistent border radius */
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-light);
            color: white; /* Default to white text for primary buttons */
        }

        .tool-card button, .summary-tool button:not(.back-to-options-btn), .validator-tool button:not(.back-to-options-btn) {
            background-color: var(--button-primary-bg);
        }
        .tool-card button:hover, .summary-tool button:not(.back-to-options-btn):hover, .validator-tool button:not(.back-to-options-btn):hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-2px); /* Slight lift on hover */
            box-shadow: 0 5px 15px var(--shadow-medium);
        }
        .tool-card button:disabled, .summary-tool button:not(.back-to-options-btn):disabled {
            background-color: var(--button-secondary-bg);
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .export-btn {
          background: var(--button-success-bg) !important;
        }
        .export-btn:hover {
          background: var(--button-success-hover) !important;
        }
        /* Positioning for Back to Options and Dark Mode Toggle */
        .back-to-options-btn {
            position: absolute;
            top: 25px; /* Default top position */
            left: 25px;
            z-index: 10;
            background-color: var(--button-secondary-bg);
            box-shadow: 0 2px 5px var(--shadow-light);
        }
        .back-to-options-btn:hover {
            background-color: var(--button-secondary-hover);
            box-shadow: 0 4px 10px var(--shadow-medium);
        }

        .summary-tool button[onclick="clearSummaryReportSearch()"],
        .validator-tool button[onclick="resetTool()"] {
            background-color: var(--button-danger-bg);
        }
        .summary-tool button[onclick="clearSummaryReportSearch()"]:hover,
        .validator-tool button[onclick="resetTool()"]:hover {
            background-color: var(--button-danger-hover);
        }

        /* Footer */
        .startup-footer, .footer-credit, .footer-validator {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            font-size: 0.85em;
            color: var(--light-text-color);
            transition: color 0.4s ease, border-color 0.4s ease;
            text-align: center;
        }
        .startup-footer strong, .footer-credit strong, .footer-validator strong {
            color: var(--text-color); /* Ensure creator name stands out */
        }

        /* Global Dark Mode Toggle Button */
        .global-dark-mode-toggle {
            position: absolute;
            top: 25px;
            right: 25px;
            background: var(--button-secondary-bg);
            color: white;
            border: none;
            padding: 10px 15px; /* Larger padding */
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
            font-size: 0.9em;
            box-shadow: 0 2px 8px var(--shadow-medium);
            transition: background-color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
            font-weight: 500;
            margin-right: 15px; /* Move slightly left */
        }
        .global-dark-mode-toggle:hover {
            background-color: var(--button-secondary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-strong);
        }


        /* Tool Specific Section Styling */
        .input-section, .chart-container, .debug-info, #errorSection, #summaryTopPerformers, .insights-section {
            background: var(--container-bg); /* Use container bg for internal sections */
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px var(--shadow-light);
            margin-bottom: 25px; /* Consistent spacing */
            border: 1px solid var(--border-color); /* Subtle border */
            transition: background-color 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease;
        }
        /* Override for summary processing section which uses processing-bg */
        .summary-tool .processing, .validator-tool .processing { /* Apply to both processing spinners */
            background: var(--processing-bg);
            border-left: 4px solid var(--accent-color);
            box-shadow: none; /* No extra shadow here */
            border-radius: 4px; /* Smaller radius for messages */
            padding: 15px; /* More compact */
            display: flex;
            align-items: center;
            gap: 15px;
            color: var(--info-text);
            font-size: 0.95em;
        }
        .summary-tool .processing .spinner, .validator-tool .processing .spinner {
            min-width: 20px;
            min-height: 20px;
            border: 3px solid var(--border-color); /* Thicker border for spinner */
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .progress-bar {
          width: 100%;
          height: 10px; /* Thicker progress bar */
          background: var(--border-color);
          border-radius: 5px;
          overflow: hidden;
          margin-top: 8px;
        }
        .progress-fill {
          height: 100%;
          background: linear-gradient(90deg, var(--accent-color), #21cbf3); /* Vibrant gradient */
          transition: width 0.3s ease;
          width: 0%;
          border-radius: 5px;
        }

        /* Message Boxes */
        .error, .success, .info {
          padding: 15px;
          border-radius: 8px; /* Consistent with other elements */
          margin: 15px 0;
          border-left: 5px solid; /* Stronger accent border */
          font-weight: 500;
          line-height: 1.5;
          transition: background-color 0.4s, color 0.4s, border-color 0.4s;
        }
        .error { background: var(--error-bg); color: var(--error-text); border-color: var(--button-danger-bg); }
        .success { background: var(--success-bg); color: var(--success-text); border-color: var(--button-success-bg); }
        .info { background: var(--info-bg); color: var(--info-text); border-color: var(--accent-color); }


        /* Form Inputs */
        /* Updated .file-input for summary to be hidden now that we have a custom upload area */
        .file-input-hidden {
            display: none;
        }

        .summary-tool textarea, .summary-tool input[type="text"], .summary-tool select,
        .validator-tool textarea { /* validator input[type="file"] is now styled by .upload-area-validator */
          width: calc(100% - 22px); /* Account for padding and border */
          padding: 12px; /* More padding */
          margin: 10px 0;
          border: 1px solid var(--input-border);
          border-radius: 8px; /* Consistent radius */
          background-color: var(--input-bg);
          color: var(--text-color);
          font-size: 1em;
          transition: background-color 0.3s, border-color 0.3s, color 0.3s, box-shadow 0.3s;
          box-sizing: border-box; /* Crucial for width calculation */
        }
        .summary-tool textarea:focus, .summary-tool input[type="text"]:focus, .summary-tool select:focus,
        .validator-tool textarea:focus {
            outline: none;
            border-color: var(--input-focus-border);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2); /* Soft blue shadow */
        }
        /* Styling for Report Type and Name Search Inputs */
        select#summaryExportTypeSelector,
        input#summaryNameInput {
            background-color: var(--info-bg); /* Use info color as background */
            border: 1px solid var(--info-text); /* Use info text color for border */
            color: var(--info-text);
            font-weight: 500;
            box-shadow: 0 1px 3px var(--shadow-light);
            transition: all 0.2s ease-in-out;
        }
        select#summaryExportTypeSelector:hover,
        input#summaryNameInput:hover {
            background-color: var(--table-hover-row); /* Use a subtle hover */
            border-color: var(--accent-color);
        }
        select#summaryExportTypeSelector:focus,
        input#summaryNameInput:focus {
            box_shadow: 0 0 0 3px var(--accent-color);
        }

        /* Stats Cards (Top Performers & Individual Report numbers) */
        .stats {
          display: grid; /* Default to grid for general stat layouts */
          grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted min-width for more cards */
          gap: 20px;
          margin: 20px 0;
        }

        /* Specific styling for Top Performers to be on one line */
        #summaryLeaderboardContainer.stats {
            display: flex;
            flex-wrap: nowrap; /* Keep items on a single line */
            overflow-x: auto; /* Allow horizontal scrolling if cards exceed width */
            justify-content: flex-start; /* Align to start */
            padding-bottom: 10px; /* Add some padding if scrollbar appears */
            gap: 15px; /* Slightly smaller gap for compact layout */
        }
        #summaryLeaderboardContainer .stat-card {
            flex-shrink: 0; /* Prevent cards from shrinking */
            min-width: 140px; /* Smaller min-width for top performers */
            padding: 12px; /* Slightly less padding for compactness */
        }
        #summaryLeaderboardContainer .stat-card .stat-number {
            font-size: 1.8em; /* Smaller font for rank */
        }
        #summaryLeaderboardContainer .stat-card .stat-label {
            font-size: 0.85em; /* Smaller font for name */
        }
        #summaryLeaderboardContainer .stat-card div:nth-of-type(3) { /* Completed Orders */
            font-size: 14px;
        }
        #summaryLeaderboardContainer .stat-card div:nth-of-type(4) { /* Total Orders */
            font-size: 11px;
        }
        #summaryLeaderboardContainer .stat-card div:nth-of-type(5) { /* Completion Rate */
            font-size: 9px;
        }


        /* Specific styling for Individual Report stat cards to be on one line */
        #summaryOutput .stats {
            display: flex;
            flex-wrap: nowrap; /* Keep items on a single line */
            overflow-x: auto; /* Allow horizontal scrolling if cards exceed width */
            justify-content: flex-start; /* Align to start */
            padding-bottom: 10px; /* Add some padding if scrollbar appears */
            gap: 15px; /* Slightly smaller gap for compact layout */
        }
        #summaryOutput .stats .stat-card {
            flex-shrink: 0; /* Prevent cards from shrinking */
            min-width: 160px; /* Ensure a minimum width for individual stat cards */
            padding: 15px; /* Slightly less padding for compactness */
            /* Individual Report specific gradient */
            background: var(--individual-report-card-bg);
            color: white; /* White text for gradient background */
        }
        [data-theme="dark"] #summaryOutput .stats .stat-card {
            background: var(--individual-report-card-bg); /* Use dark theme specific variable */
            color: white;
        }

        .stat-card {
          background: var(--container-bg); /* Default background, overridden by specific gradients */
          color: var(--text-color);
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          box-shadow: 0 4px 12px var(--shadow-light);
          border: 1px solid var(--border-color);
          transition: background-color 0.4s, color 0.4s, box-shadow 0.4s, border-color 0.4s;
        }

        /* Performer specific colors applied by JS via inline style for Top Performers */
        /* Individual report stat cards are styled by --individual-report-card-bg */
        .stat-card .stat-number {
          font-weight: 700;
          margin-bottom: 5px;
          color: white; /* Always white on gradient background */
        }
        .stat-card .stat-label {
          opacity: 0.9; /* Slightly less opaque */
          color: white; /* Always white on gradient background */
        }
        .stat-card div:not(.stat-number):not(.stat-label) {
            color: white !important; /* Ensure all text in stat-card is white */
        }


        /* Charts */
        .chart-row {
          display: flex;
          flex-wrap: wrap;
          gap: 25px;
          margin-bottom: 25px;
        }
        .chart-wrapper {
          flex: 1;
          min-width: 350px; /* Minimum width for charts */
          background: var(--container-bg);
          padding: 20px;
          border-radius: 10px;
          box-shadow: 0 2px 10px var(--shadow-light);
          border: 1px solid var(--border-color);
          transition: background-color 0.4s, box-shadow 0.4s, border-color 0.4s;
        }

        /* Tables (General for both tools) */
        table {
          border-collapse: collapse;
          width: 100%;
          margin-top: 25px;
          box-shadow: 0 2px 10px var(--shadow-light);
          border-radius: 10px; /* Overall table rounded corners */
          overflow: hidden; /* Ensures rounded corners apply to content */
          border: 1px solid var(--table-border-outer);
        }
        th, td {
          border: 1px solid var(--table-border-inner);
          padding: 12px 15px; /* More padding for cells */
          text-align: left;
          font-size: 0.95em;
          transition: background-color 0.4s, color 0.4s, border-color 0.4s;
        }
        th {
          background: var(--table-header-bg);
          color: var(--table-header-text);
          font-weight: 600;
          text-align: center;
          white-space: nowrap; /* Prevent headers from wrapping too much */
        }
        tr:nth-child(even) { background-color: var(--table-even-row); }
        tr:hover { background-color: var(--table-hover-row); }

        /* New: Highlighted cells in Error Table (Order Validator) */
        #errorTable td {
            background: linear-gradient(135deg, var(--highlight-gradient-start) 0%, var(--highlight-gradient-end) 100%);
            color: var(--highlight-text-color);
            font-weight: 500;
            transition: background 0.4s ease, color 0.4s ease;
        }
        #errorTable tr:hover td {
            background: linear-gradient(135deg, var(--table-hover-row) 0%, var(--highlight-gradient-start) 100%);
            color: var(--text-color);
        }
        /* Ensure the "No errors found" cell isn't highlighted */
        #errorTable tbody tr:last-child td[colspan="4"] {
            background: transparent !important;
            color: var(--text-color) !important;
            font-weight: normal !important;
        }


        /* Specific styles for validator message box */
        .message-box-custom {
            background-color: var(--info-bg);
            color: var(--info-text);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            max-width: 450px; /* Slightly wider for better text flow */
            margin: 20px auto;
            text-align: center;
            box-shadow: 0 4px 15px var(--shadow-medium);
            position: fixed; /* Keep it in viewport */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000; /* Ensure it's on top */
            display: block; /* Ensure it's shown */
            transition: all 0.3s ease-in-out;
            opacity: 1;
        }
        .message-box-custom button {
            margin-top: 15px;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 5px var(--shadow-light);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        }
        .message-box-custom.info button { background-color: var(--button-secondary-bg); color: white; }
        .message-box-custom.info button:hover { background-color: var(--button-secondary-hover); }
        .message-box-custom.error button { background-color: var(--button-danger-bg); color: white; }
        .message-box-custom.error button:hover { background-color: var(--button-danger-hover); }

        /* Validator Specific UI enhancements for file upload/paste */
        .upload-area { /* Renamed for general use */
            border: 2px dashed var(--input-border);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            background: var(--input-bg);
            margin-bottom: 25px;
            transition: all 0.3s ease;
            position: relative; /* For file input positioning */
        }

        .upload-area.drag-over {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.2);
            background-color: var(--processing-bg);
        }

        .upload-area p {
            color: var(--light-text-color);
            margin-bottom: 15px;
        }

        .upload-area label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-color);
        }

        .upload-area .file-input-hidden {
            display: none; /* Hide the default file input */
        }

        .drop-zone-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 25px;
            font-size: 1em;
            background-color: var(--button-primary-bg);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-light);
            margin-bottom: 20px; /* Space before paste area */
        }

        .drop-zone-button:hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-medium);
        }

        .drop-zone-button svg {
            margin-right: 8px;
        }

        .separator {
            margin: 20px 0;
            color: var(--light-text-color);
            font-size: 0.9em;
            position: relative;
            text-align: center;
        }
        .separator::before, .separator::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%; /* Adjust width as needed */
            height: 1px;
            background-color: var(--border-color);
        }
        .separator::before {
            left: 0;
        }
        .separator::after {
            right: 0;
        }

        .file-name-display { /* Renamed for general use */
            margin-top: 15px;
            font-style: italic;
            color: var(--accent-color);
            font-weight: 500;
            font-size: 0.95em;
            min-height: 1.2em; /* Reserve space to prevent layout shift */
        }

        /* Insights Section */
        .insights-section {
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px var(--shadow-light);
            margin-top: 25px;
            border: 1px solid var(--border-color);
            background: var(--container-bg);
        }
        .insights-section h3 {
            margin-bottom: 15px;
            color: var(--text-color);
        }
        .insights-section p {
            margin-bottom: 10px;
            color: var(--text-color);
        }
        .insights-section strong {
            color: var(--accent-color);
        }

        /* Startup page loader */
        #startupLoader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 1.2em;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(5px); /* Safari support */
            transition: opacity 0.3s ease;
        }
        #startupLoader .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        #startupLoader .loader-text {
            margin-bottom: 15px;
        }
        #startupLoader .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        #startupLoader .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #8bc34a, #aed581); /* Green gradient */
            border-radius: 4px;
            transition: width 0.3s ease;
        }


        /* Responsiveness */
        @media (max-width: 768px) {
            body { padding: 15px; }
            .nav-buttons-container, .tool-container {
                padding: 25px;
            }
            .app-header h1, .tool-container h1 {
                font-size: 2.2em;
                padding-top: 15px; /* Adjust padding for smaller screens */
            }
            .tool-card {
                min-width: 280px;
                padding: 20px;
            }
            .tool-card h2 {
                font-size: 1.6em;
            }
            .stats {
                grid-template-columns: 1fr; /* Stack on small screens for general stats */
            }
            #summaryLeaderboardContainer.stats,
            #summaryOutput .stats {
                flex-wrap: wrap; /* Allow wrapping on very small screens if necessary */
                justify-content: center;
            }
            .chart-wrapper {
                min-width: 100%;
            }
            th, td {
                padding: 8px 10px;
                font-size: 0.85em;
            }
            .global-dark-mode-toggle {
                top: 15px;
                right: 15px; /* Adjust for smaller screens */
                padding: 8px 10px;
                font-size: 0.8em;
                margin-right: 0; /* No extra margin on small screens */
            }
            .back-to-options-btn {
                top: 15px; /* Adjust for smaller screens */
                left: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Initial Startup Options -->
    <div id="startupOptions" class="nav-buttons-container">
        <!-- Dark Mode Toggle (now global) -->
        <button id="globalDarkModeToggle" class="global-dark-mode-toggle">🌙 Dark Mode</button>
        <div class="app-header">
            <h1>📦 Order Management Suite</h1>
            <p>The Order Management Tool is a web-based solution designed for the Premier Packaging project under ActioHX. It streamlines daily order tracking, performance analytics, and data validation — all in a single interface.</p>
            <p>Built with modern web technologies, this lightweight yet powerful tool enables the Operations team to visualize, validate, and export order data with zero installation and 100% browser-based execution.</p>
        </div>

        <div class="tool-selection">
            <div class="tool-card">
                <h2>📊 SummaryX</h2>
                <ul>
                    <li>Generate detailed performance reports by assignee.</li>
                    <li>Identify single vs. multi-line orders.</li>
                    <li>Visualize order status and type distribution.</li>
                    <li>Detect top performers across various metrics.</li>
                    <li>Export comprehensive Excel reports.</li>
                    <li>Time-based Order Trends & Peak Performance Analysis.</li>
                </ul>
                <button onclick="launchToolWithLoader('summary')">Launch SummaryX</button>
            </div>
            <div class="tool-card">
                <h2>✅ ValidatorPro</h2>
                <ul>
                    <li>Detect errors in batch time vs. order status logic.</li>
                    <li>Identify missing or incorrect “Reason for Pending.”</li>
                    <li>Highlights discrepancies for easy review.</li>
                    <li>Exports a clean error report in tabular format.</li>
                </ul>
                <button onclick="launchToolWithLoader('validation')">Launch ValidatorPro</button>
            </div>
        </div>
        <footer class="startup-footer">
            <p>&copy; 2025 ActioHX. All rights reserved.</p>
			<p>Crafted with precision by <strong>Saikat Majumder</strong></p>
            <p>Tool Version: v1.2</p>
        </footer>
		
    </div>

    <!-- Startup Loader Overlay -->
    <div id="startupLoader" style="display: none;">
        <div class="spinner"></div>
        <div class="loader-text" id="loaderText">Loading tool...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="loaderProgressFill"></div>
        </div>
    </div>


    <!-- Order Summary Tool Section -->
    <div id="summaryTool" class="tool-container summary-tool" style="display: none;">
        <button onclick="showOptions()" class="back-to-options-btn">← Back to Options</button>
        <!-- Dark Mode Toggle (now global and positioned within the tool) -->
        <button id="summaryDarkModeToggle" class="global-dark-mode-toggle">🌙 Dark Mode</button>
        <div class="main-container" id="summaryMainContainer">
            <div class="container container-summary">
                <div class="header-section">
                    <div>
                        <h1 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                            📊 SummaryX
                        </h1>
                        <p style="margin: 5px 0 0 0; color: var(--light-text-color); font-size: 1em; transition: color 0.3s ease;">
                            Enhanced with Smart Analytics & Offline Features
                        </p>
                    </div>
                </div>
                <div class="input-section" id="summaryInputSection">
                    <h3>Data Input</h3>
                    <div class="upload-area" id="summaryUploadArea">
                        <p style="font-size: 1.1em; color: var(--text-color); margin-bottom: 20px;">
                            Drag & drop your Excel (.xlsx, .xls) or CSV file here, or click to upload.
                        </p>
                        <input type="file" id="summaryFileInput" accept=".xlsx,.xls,.csv" class="file-input-hidden">
                        <button type="button" class="drop-zone-button" onclick="document.getElementById('summaryFileInput').click()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-upload-cloud"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></svg>
                            Choose File
                        </button>
                        <div id="summaryFileNameDisplay" class="file-name-display"></div> <!-- Added for file name display -->
                        <div class="separator">— OR —</div>
                        <textarea id="summaryManualInput" rows="8" placeholder="Paste your CSV data here (with headers)&#10;&#10;Expected columns: Order#, Line, Assigned_To, Status, Type, Order Date&#10;&#10;Example:&#10;Order#,Line,Assigned_To,Status,Type,Order Date&#10;12345,1,John Doe,Awaiting Response,AIR,2024-01-15&#10;12345,2,John Doe,In Progress,AIR,2024-01-15"></textarea>
                        
                    </div>
                    <button onclick="triggerSummaryAnalysis()">📝 Process Data</button>
                </div>

                <div id="summaryProcessing" class="processing">
                    <div class="spinner"></div>
                    <div>
                        <div id="summaryProcessingText">Processing data...</div>
                        <div class="progress-bar">
                            <div id="summaryProgressFill" class="progress-fill"></div>
                        </div>
                        <div id="summaryProcessingStats" style="font-size: 0.85em; color: var(--info-text); transition: color 0.3s ease;"></div>
                    </div>
                </div>

                <div id="summaryMessages"></div>

                <div id="summaryControls" style="display: none; padding: 25px; border-radius: 10px; border: 1px solid var(--border-color); background: var(--container-bg); box-shadow: 0 2px 10px var(--shadow-light); margin-bottom: 25px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center; margin-bottom: 20px;">
                        <select id="summaryExportTypeSelector" style="flex: 1; min-width: 180px;">
                            <option value="">Select Report Type</option>
                            <option value="all">📤 Export All Users Data</option>
                            <option value="status">📊 Export Status-wise Data</option>
                        </select>
                        <button onclick="handleSummaryExport()" class="export-btn" style="flex-grow: 0;">⬇️ Export</button>
                        <!-- New button for showing trends -->
                        <button onclick="showTimeBasedTrends()" style="flex-grow: 0; background-color: var(--button-secondary-bg);">
                            📊 Show Trend Analysis
                        </button>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                        <input type="text" id="summaryNameInput" list="summaryNameSuggestions" placeholder="Type name to search for report..." style="flex: 1; min-width: 180px;">
                        <datalist id="summaryNameSuggestions"></datalist>
                        <button onclick="searchSummaryReportByName()" style="flex-grow: 0;">🔍 Search Report</button>
                        <button onclick="clearSummaryReportSearch()">🔄 Reset Search</button>
                    </div>
                </div>
                <!-- 🏆 Top Performer Leaderboard -->
                <div id="summaryTopPerformers" style="margin: 25px 0; display: none;">
                    <h3 style="margin-bottom: 15px; color: var(--text-color); transition: color 0.3s ease;">🏆 Top Performers</h3>
                    <div id="summaryLeaderboardContainer" class="stats"></div>
                    <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--border-color); transition: border-color 0.3s ease;">
                </div>

                <div id="summaryOutput"></div>

                <!-- Time-based Trend Charts -->
                <div id="summaryTrendCharts" style="display: none; margin-top: 25px;">
                    <h3 style="margin-bottom: 15px; color: var(--text-color); transition: color 0.3s ease;">📈 Time-based Order Trends</h3>
                    <div class="chart-row">
                        <div class="chart-wrapper">
                            <canvas id="dailyOrderCountChart"></canvas>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="dailyCompletionRateChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Peak Performance Analysis -->
                <div id="summaryPeakPerformance" class="insights-section" style="display: none;">
                    <h3 style="margin-bottom: 15px; color: var(--text-color); transition: color 0.3s ease;">⚡ Peak Performance Insights</h3>
                    <p id="peakOrderVolume"></p>
                    <p id="peakCompletionRate"></p>
                </div>

                <div class="footer-credit">
                    ✦ Created by Saikat Majumder © 2025
                </div>
            </div>
        </div>

        <script>
            let allSummaryData = [];
            let processingSummaryStartTime = 0;
            // Updated expectedSummaryColumns to include 'Order Date'
            const expectedSummaryColumns = ['Order#', 'Line', 'Assigned_To', 'Status', 'Type', 'Order Date']; 

            function showSummaryMessage(message, type = 'info') {
              const messagesDiv = document.getElementById('summaryMessages');
              const messageDiv = document.createElement('div');
              messageDiv.className = type;
              messageDiv.innerHTML = message;
              messagesDiv.appendChild(messageDiv);

              if (type === 'success') {
                setTimeout(() => messageDiv.remove(), 5000);
              }
            }

            function clearSummaryMessages() {
              document.getElementById('summaryMessages').innerHTML = '';
            }

            function showSummaryProcessing(show = true, text = 'Processing data...') {
              document.getElementById('summaryProcessing').style.display = show ? 'flex' : 'none';
              if (show) {
                processingSummaryStartTime = Date.now();
                updateSummaryProgress(0, text);
              }
            }

            function updateSummaryProgress(percent, text = 'Processing data...', stats = '') {
              document.getElementById('summaryProgressFill').style.width = percent + '%';
              document.getElementById('summaryProcessingText').textContent = text;
              document.getElementById('summaryProcessingStats').textContent = stats;
            }

            function cleanAndValidateSummaryData(data) {
                if (!data || data.length === 0) {
                    throw new Error('No data found in the file/input.');
                }

                // Create a deep copy to ensure original data from XLSX.utils.sheet_to_json is not modified
                let cleanedData = JSON.parse(JSON.stringify(data));

                // Aggressive trimming and cleaning for all values
                cleanedData = cleanedData.map(row => {
                    const newRow = {};
                    for (const key in row) {
                        // Ensure key is a string and handle null/undefined values
                        const cleanedKey = typeof key === 'string' ? key.trim() : key;
                        newRow[cleanedKey] = typeof row[key] === 'string' ? row[key].trim() : row[key];
                    }
                    return newRow;
                });

                // Remove empty rows (rows where all values are empty strings or only whitespace)
                cleanedData = cleanedData.filter(row => {
                    return Object.values(row).some(val => val !== null && val !== undefined && String(val).trim() !== '');
                });

                // If no valid data rows remain after cleaning, throw an error
                if (cleanedData.length === 0) {
                    throw new Error('No valid data rows remaining after cleaning. Please check your data for content.');
                }

                // Get current headers after initial cleaning
                let currentHeaders = Object.keys(cleanedData[0]);

                console.log('--- Debugging Headers ---');
                console.log('Expected columns:', expectedSummaryColumns);
                console.log('Actual headers found (before normalization):', currentHeaders);

                // Normalize headers in the actual data for consistent access
                const normalizedData = cleanedData.map(row => {
                  const newRow = {};
                  Object.keys(row).forEach(key => {
                    let foundExpectedKey = null;
                    // Attempt to find a match for the current 'key' from 'expectedSummaryColumns'
                    // Prioritize exact match, then case-insensitive, then aggressive normalization
                    for (const expectedCol of expectedSummaryColumns) {
                        // Aggressive normalization: remove all non-alphanumeric characters (including spaces, underscores)
                        const keyNormalizedForComparison = String(key).replace(/\W/g, '').toLowerCase(); // \W matches non-word characters
                        const expectedColNormalizedForComparison = String(expectedCol).replace(/\W/g, '').toLowerCase();

                        if (key === expectedCol || // Exact match (case-sensitive)
                            key.toLowerCase() === expectedCol.toLowerCase() || // Case-insensitive match
                            keyNormalizedForComparison === expectedColNormalizedForComparison) // Aggressive alphanumeric comparison
                        {
                            foundExpectedKey = expectedCol; // Use the *exact* expected column name
                            break;
                        }
                    }
                    // Assign value to the 'foundExpectedKey' or fallback to original key if no expected match
                    newRow[foundExpectedKey || key] = row[key];
                  });
                  return newRow;
                });

                // After normalization, check for missing columns using the *standardized* expected names
                const finalHeaders = Object.keys(normalizedData[0] || {});
                const missingColumns = expectedSummaryColumns.filter(col => !finalHeaders.includes(col));

                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}. Please ensure they are present and correctly spelled in your file header.`);
                }
                
                console.log('Actual headers found (after normalization, now matching expected names):', Object.keys(normalizedData[0] || {}));
                console.log('--- End Debugging Headers ---');

                return normalizedData;
            }

            async function triggerSummaryAnalysis() {
                const fileInput = document.getElementById('summaryFileInput');
                const manualInput = document.getElementById('summaryManualInput');
                let rawData;
                let sourceFileName = '';

                clearSummaryMessages();
                showSummaryProcessing(true, 'Detecting data source...');

                try {
                    if (fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        sourceFileName = file.name;
                        updateSummaryProgress(10, 'Reading file...', `File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`);

                        const fileName = file.name.toLowerCase();

                        if (fileName.endsWith('.csv')) {
                            const text = await file.text();
                            updateSummaryProgress(30, 'Parsing CSV data...');
                            const result = Papa.parse(text, {
                                header: true,
                                skipEmptyLines: false,
                                dynamicTyping: true,
                                delimitersToGuess: [',', '\t', '|', ';'],
                                transformHeader: header => header.trim()
                            });
                            if (result.errors.length > 0) {
                                console.warn('CSV parsing warnings:', result.errors);
                            }
                            rawData = result.data;
                        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                            updateSummaryProgress(20, 'Reading Excel file...');
                            const arrayBuffer = await file.arrayBuffer();
                            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            updateSummaryProgress(40, 'Converting Excel data...');
                            // XLSX.utils.sheet_to_json by default uses the first row as headers
                            rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {
                                defval: '', // Set default value for empty cells
                                raw: false // Get formatted cell values, not raw numbers/dates
                            });
                        } else {
                            throw new Error('Unsupported file format. Please use CSV, XLS, or XLSX files.');
                        }
                    } else if (manualInput.value.trim() !== "") {
                        const raw = manualInput.value.trim();
                        updateSummaryProgress(20, 'Parsing manual input...');
                        const result = Papa.parse(raw, {
                            header: true,
                            skipEmptyLines: false,
                            dynamicTyping: true,
                            delimitersToGuess: [',', '\t', '|', ';'],
                            transformHeader: header => header.trim()
                        });
                        if (result.errors.length > 0) {
                            console.warn('CSV parsing warnings:', result.errors);
                        }
                        rawData = result.data;
                    } else {
                        throw new Error('No file selected and no data pasted. Please upload a file or paste data.');
                    }
                    
                    updateSummaryProgress(50, 'Cleaning and validating data structure...');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    allSummaryData = cleanAndValidateSummaryData(rawData);

                    updateSummaryProgress(70, 'Processing orders...', `Found ${allSummaryData.length} rows`);
                    await new Promise(resolve => setTimeout(resolve, 200));

                    buildSummarySelector();

                    updateSummaryProgress(90, 'Finalizing...');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const processingTime = ((Date.now() - processingSummaryStartTime) / 1000).toFixed(1);
                    updateSummaryProgress(100, 'Complete!', `Processed ${allSummaryData.length} rows in ${processingTime}s`);

                    setTimeout(() => {
                        showSummaryProcessing(false);
                        let successMessage = `✅ Successfully processed ${allSummaryData.length} rows.`;
                        if (sourceFileName) {
                            successMessage += ` from ${sourceFileName}`;
                        }
                        showSummaryMessage(successMessage, 'success');
                        
                        // After processing, show top performers by default and hide trends
                        hideAllSummaryOutputs();
                        document.getElementById('summaryTopPerformers').style.display = 'block';
                        renderSummaryTopPerformers();

                        document.getElementById('summaryControls').style.display = 'block';
                        // Trends are now shown via the dedicated button
                        // document.getElementById('summaryTrendCharts').style.display = 'block'; 
                        // document.getElementById('summaryPeakPerformance').style.display = 'block'; 
                    }, 500);

                } catch (error) {
                    showSummaryProcessing(false);
                    showSummaryMessage(`❌ Error processing data: ${error.message}`, 'error');
                }
            }


            function buildSummarySelector() {
              const nameSet = new Set(
                allSummaryData
                  .map(r => r['Assigned_To'])
                  .filter(name => name && typeof name === 'string' && name.trim())
                  .map(name => name.trim())
              );

              const datalist = document.getElementById('summaryNameSuggestions');
              datalist.innerHTML = '';

              [...nameSet].sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                datalist.appendChild(option);
              });

              showSummaryMessage(`ℹ️ Found ${nameSet.size} unique assignees in the data`, 'info');
            }

            function renderSummaryCharts(name, statusData, typeData) {
              const statusChartElement = document.getElementById('summaryStatusChart');
              const typeChartElement = document.getElementById('summaryTypeChart');

              if (window.summaryStatusChart instanceof Chart) {
                window.summaryStatusChart.destroy();
              }
              if (window.summaryTypeChart instanceof Chart) {
                window.summaryTypeChart.destroy();
              }

              // Define colors that work well in both light and dark modes
              // Explicitly defining colors for "Completed", "In Progress", "Awaiting", "AC Mgr"
              const lightModeColors = [
                  '#28a745', /* Completed - Green */
                  '#007bff', /* In Progress - Blue */
                  '#ffc107', /* Awaiting - Yellow/Orange */
                  '#dc3545', /* AC Mgr - Red */
                  '#4e79a7', '#f28e2b', '#e15759', '#76b7b2', '#59a14f', '#edc948', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ac' // More for other statuses/types if needed
              ];
              const darkModeColors = [
                  '#6a9c6a', /* Completed - Lighter Green for dark mode */
                  '#61afef', /* In Progress - Lighter Blue for dark mode */
                  '#ffce56', /* Awaiting - Lighter Yellow/Orange for dark mode */
                  '#e06c75', /* AC Mgr - Lighter Red for dark mode */
                  '#7cb5ec', '#f7a35c', '#90ed7d', '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1', '#666666' // More for other statuses/types if needed
              ];

              const currentThemeColors = document.documentElement.getAttribute('data-theme') === 'dark' ? darkModeColors : lightModeColors;

              // Map status labels to colors based on the desired order
              const statusLabels = Object.keys(statusData);
              const statusColorMap = {
                  'Completed': currentThemeColors[0],
                  'In Progress': currentThemeColors[1],
                  'Awaiting': currentThemeColors[2],
                  'AC Mgr': currentThemeColors[3]
              };
              const statusBackgroundColors = statusLabels.map(label => statusColorMap[label] || currentThemeColors[4]); // Fallback


              if (Object.keys(statusData).length > 0) {
                window.summaryStatusChart = new Chart(statusChartElement, {
                  type: 'pie',
                  data: {
                    labels: statusLabels,
                    datasets: [{
                      data: Object.values(statusData),
                      backgroundColor: statusBackgroundColors,
                      borderWidth: 1
                    }]
                  },
                  options: {
                    responsive: true,
                    plugins: {
                      legend: {
                          position: 'right',
                          labels: {
                              color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                          }
                      },
                      title: {
                          display: true,
                          text: 'Order Status Distribution',
                          color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                      }
                    }
                  }
                });
              }
              if (Object.keys(typeData).length > 0) {
                window.summaryTypeChart = new Chart(typeChartElement, {
                  type: 'bar',
                  data: {
                    labels: Object.keys(typeData),
                    datasets: [{
                      label: 'Order Count',
                      data: Object.values(typeData),
                      backgroundColor: currentThemeColors[0], /* Use a consistent color for bar chart, e.g., the 'Completed' green */
                      borderWidth: 1
                    }]
                  },
                  options: {
                    responsive: true,
                    plugins: {
                      legend: { display: false },
                      title: {
                          display: true,
                          text: 'Order Types Breakdown',
                          color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                      }
                    },
                    scales: {
                      y: {
                        beginAtZero: true,
                        ticks: {
                            color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                        },
                        grid: {
                            color: getComputedStyle(document.documentElement).getPropertyValue('--border-color')
                        }
                      },
                      x: {
                        ticks: {
                            color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                        },
                        grid: {
                            color: getComputedStyle(document.documentElement).getPropertyValue('--border-color')
                        }
                      }
                    }
                  }
                });
              }
            }

            // New: Render Time-based Trend Charts
            function renderSummaryTrendCharts() {
                const dailyOrderCountChartElement = document.getElementById('dailyOrderCountChart');
                const dailyCompletionRateChartElement = document.getElementById('dailyCompletionRateChart');

                if (window.dailyOrderCountChart instanceof Chart) {
                    window.dailyOrderCountChart.destroy();
                }
                if (window.dailyCompletionRateChart instanceof Chart) {
                    window.dailyCompletionRateChart.destroy();
                }

                const dailyTrends = calculateDailyTrends(allSummaryData);
                const dates = Object.keys(dailyTrends).sort();
                const totalOrdersPerDay = dates.map(date => dailyTrends[date].totalOrders);
                const completionRatesPerDay = dates.map(date => {
                    const total = dailyTrends[date].totalOrders;
                    const completed = dailyTrends[date].completedOrders;
                    return total > 0 ? ((completed / total) * 100).toFixed(1) : 0;
                });

                const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color');
                const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
                const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
                const successColor = getComputedStyle(document.documentElement).getPropertyValue('--button-success-bg');


                if (dates.length > 0) {
                    window.dailyOrderCountChart = new Chart(dailyOrderCountChartElement, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Total Orders',
                                data: totalOrdersPerDay,
                                borderColor: accentColor,
                                backgroundColor: 'rgba(0, 123, 255, 0.2)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    labels: { color: textColor }
                                },
                                title: {
                                    display: true,
                                    text: 'Daily Total Orders',
                                    color: textColor
                                }
                            },
                            scales: {
                                x: {
                                    ticks: { color: textColor },
                                    grid: { color: borderColor }
                                },
                                y: {
                                    beginAtZero: true,
                                    ticks: { color: textColor },
                                    grid: { color: borderColor }
                                }
                            }
                        }
                    });

                    window.dailyCompletionRateChart = new Chart(dailyCompletionRateChartElement, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Daily Completion Rate (%)',
                                data: completionRatesPerDay,
                                borderColor: successColor,
                                backgroundColor: 'rgba(40, 167, 69, 0.2)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    labels: { color: textColor }
                                },
                                title: {
                                    display: true,
                                    text: 'Daily Completion Rate',
                                    color: textColor
                                }
                            },
                            scales: {
                                x: {
                                    ticks: { color: textColor },
                                    grid: { color: borderColor }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: { color: textColor },
                                    grid: { color: borderColor }
                                }
                            }
                        }
                    });
                }
            }

            // New: Function to calculate daily trends
            function calculateDailyTrends(data) {
                const dailyStats = {};
                const orderMap = {};
                const orderStatusMap = {};

                // First, build a map of unique orders and their final status
                data.forEach(row => {
                    const order = row['Order#'];
                    if (!order) return;

                    const status = (row['Status'] || '').toString().toLowerCase();
                    const assigned = (row['Assigned_To'] || '').toString().trim();

                    if (!orderMap[order]) orderMap[order] = [];
                    orderMap[order].push(row);

                    if (!orderStatusMap[order]) {
                        orderStatusMap[order] = { status: 'in_progress', assignedTo: assigned };
                    }
                    if (status.includes('completed')) {
                        orderStatusMap[order] = { status: 'completed', assignedTo: assigned };
                    } else if (assigned.toLowerCase().includes('acmgr') || status.includes('ac mgr')) {
                        if (orderStatusMap[order].status !== 'completed') {
                            orderStatusMap[order] = { status: 'ac_mgr', assignedTo: assigned };
                        }
                    } else if (status.includes('awaiting')) {
                        if (!['completed', 'ac_mgr'].includes(orderStatusMap[order].status)) {
                            orderStatusMap[order] = { status: 'awaiting', assignedTo: assigned };
                        }
                    }
                });

                // Now, iterate through unique orders (using Line 1 for date and assignee)
                // and populate daily stats
                const processedOrders = new Set(); // To ensure each order is counted once per day
                data.forEach(row => {
                    const order = row['Order#'];
                    // Use 'Order Date' column for date trend
                    const orderDateStr = row['Order Date']; 
                    if (!order || !orderDateStr || processedOrders.has(order)) return; // Skip if already counted

                    // Normalize date string to YYYY-MM-DD for consistent keys
                    let dateKey = '';
                    try {
                        let parsedDate = null;
                        // Attempt to parse as a direct Date object if XLSX.utils.sheet_to_json already converted it
                        if (orderDateStr instanceof Date && !isNaN(orderDateStr.getTime())) {
                            parsedDate = orderDateStr;
                        } else {
                            const s = String(orderDateStr).trim();
                            const formats = [
                                (str) => { // YYYY-MM-DD (ISO-like)
                                    const match = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                                    return match ? new Date(str) : null;
                                },
                                (str) => { // MM/DD/YYYY or MM-DD-YYYY
                                    const match = str.match(/^(\d{1,2})[/-](\d{1,2})[/-](\d{2,4})$/);
                                    if (match) {
                                        const year = match[3].length === 2 ? `20${match[3]}` : match[3];
                                        return new Date(`${year}-${match[1]}-${match[2]}`); // Converts to YYYY-MM-DD internally
                                    }
                                    return null;
                                },
                                (str) => { // DD/MM/YYYY or DD-MM-YYYY
                                    const match = str.match(/^(\d{1,2})[/-](\d{1,2})[/-](\d{2,4})$/);
                                    if (match) {
                                        const year = match[3].length === 2 ? `20${match[3]}` : match[3];
                                        return new Date(`${year}-${match[2]}-${match[1]}`); // Converts to YYYY-MM-DD internally
                                    }
                                    return null;
                                },
                                (str) => { // YYYY/MM/DD
                                    const match = str.match(/^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$/);
                                    return match ? new Date(str.replace(/\//g, '-')) : null;
                                },
                                (str) => { // DD-Mon-YYYY (e.g., 15-Jan-2024) - generic Date constructor
                                    const date = new Date(str);
                                    return isNaN(date.getTime()) ? null : date;
                                }
                            ];

                            for (const parser of formats) {
                                parsedDate = parser(s);
                                if (parsedDate && !isNaN(parsedDate.getTime())) {
                                    break; // Found a valid date, stop trying formats
                                }
                            }
                        }
                        
                        if (parsedDate && !isNaN(parsedDate.getTime())) {
                            dateKey = parsedDate.toISOString().slice(0, 10); // Ensures YYYY-MM-DD format
                        } else {
                            console.warn(`Failed to parse date string: "${orderDateStr}" for Order#: ${order}. Original type: ${typeof orderDateStr}.`);
                        }
                    } catch (e) {
                        console.warn(`Error processing date "${orderDateStr}" for order ${order}:`, e);
                        return; // Skip this row if date parsing leads to an error
                    }

                    if (!dateKey) {
                        console.warn(`Skipping row for Order#: ${order} due to unparsable date: "${orderDateStr}".`);
                        return; // Skip if date couldn't be parsed after all attempts
                    }

                    if (!dailyStats[dateKey]) {
                        dailyStats[dateKey] = { totalOrders: 0, completedOrders: 0 };
                    }

                    const orderStatus = orderStatusMap[order];
                    if (orderStatus && orderStatus.status === 'completed' && String(row['Assigned_To'] || '').trim() === orderStatus.assignedTo.trim()) {
                        dailyStats[dateKey].completedOrders++;
                    }
                    dailyStats[dateKey].totalOrders++;
                    processedOrders.add(order); // Mark order as processed for this day
                });
                return dailyStats;
            }

            // New: Render Peak Performance Analysis
            function renderPeakPerformanceAnalysis() {
                const dailyTrends = calculateDailyTrends(allSummaryData);
                const dates = Object.keys(dailyTrends).sort();

                let peakOrderVolumeDay = null;
                let maxOrders = -1; // Initialize with -1 to handle zero orders correctly
                let peakCompletionRateDay = null;
                let maxCompletionRate = -1; // Initialize with -1 to handle zero completion correctly

                dates.forEach(date => {
                    const total = dailyTrends[date].totalOrders;
                    const completed = dailyTrends[date].completedOrders;
                    const completionRate = total > 0 ? (completed / total) * 100 : 0;

                    if (total > maxOrders) {
                        maxOrders = total;
                        peakOrderVolumeDay = date;
                    }

                    // For completion rate, also consider cases where total is 0, implying 0%
                    if (completionRate > maxCompletionRate) {
                        maxCompletionRate = completionRate;
                        peakCompletionRateDay = date;
                    }
                });

                const peakOrderVolumeP = document.getElementById('peakOrderVolume');
                const peakCompletionRateP = document.getElementById('peakCompletionRate');
                const summaryPeakPerformanceDiv = document.getElementById('summaryPeakPerformance');

                if (peakOrderVolumeDay !== null) { // Check against null, as 0 orders is a valid stat
                    peakOrderVolumeP.innerHTML = `Highest Order Volume: <strong>${maxOrders} orders</strong> on <strong>${peakOrderVolumeDay}</strong>`;
                } else {
                    peakOrderVolumeP.innerHTML = `No data to determine peak order volume.`;
                }

                if (peakCompletionRateDay !== null) { // Check against null
                    peakCompletionRateP.innerHTML = `Highest Completion Rate: <strong>${maxCompletionRate.toFixed(1)}%</strong> on <strong>${peakCompletionRateDay}</strong>`;
                } else {
                    peakCompletionRateP.innerHTML = `No data to determine peak completion rate.`;
                }

                // This section's visibility is now managed by showTimeBasedTrends()
                // summaryPeakPerformanceDiv.style.display = 'block'; 
            }


            function generateSummaryReport(name) {
                hideAllSummaryOutputs(); // Hide other outputs when an individual report is generated
                document.getElementById('summaryOutput').style.display = 'block'; // Show the output div

              try {
                const line1 = allSummaryData.filter(r => parseInt(r['Line']) === 1 && r['Assigned_To'] && r['Assigned_To'].trim() === name );
                const orderMap = {};
                const orderStatusMap = {};

                allSummaryData.forEach(row => {
                  const order = row['Order#'];
                  if (!order) return;
                  const status = (row['Status'] || '').toString().toLowerCase();
                  const assigned = (row['Assigned_To'] || '').toString().trim();
                  if (!orderMap[order]) orderMap[order] = [];
                  orderMap[order].push(row);

                  if (!orderStatusMap[order]) {
                    orderStatusMap[order] = { status: 'in_progress', assignedTo: assigned };
                  }
                  if (status.includes('completed')) {
                    orderStatusMap[order] = { status: 'completed', assignedTo: assigned };
                  } else if (assigned.toLowerCase().includes('acmgr') || status.includes('ac mgr')) {
                    if (orderStatusMap[order].status !== 'completed') {
                      orderStatusMap[order] = { status: 'ac_mgr', assignedTo: assigned };
                    }
                  } else if (status.includes('awaiting')) {
                    if (!['completed', 'ac_mgr'].includes(orderStatusMap[order].status)) {
                      orderStatusMap[order] = { status: 'awaiting', assignedTo: assigned };
                    }
                  }
                });

                const userOrders = line1.map(r => r['Order#']).filter(Boolean);
                const uniqueUserOrders = [...new Set(userOrders)].filter(order => {
                  const orderStatus = orderStatusMap[order];
                  return !orderStatus || orderStatus.assignedTo.trim() === name || !['completed', 'ac_mgr'].includes(orderStatus.status);
                });

                const typeCounts = {};
                const completedOrders = [];
                const acMgrOrders = [];
                const awaitingOrders = [];
                const inProgressOrders = [];
                const singleLine = [];
                const multiLine = [];

                uniqueUserOrders.forEach(order => {
                  const rows = orderMap[order] || [];
                  const orderStatus = orderStatusMap[order];

                  const line1Row = rows.find(r => parseInt(r['Line']) === 1);
                  if (line1Row && line1Row['Type']) {
                    const type = line1Row['Type'].toString().trim();
                    if (type) {
                      typeCounts[type] = (typeCounts[type] || 0) + 1;
                    }
                  }

                  if (orderStatus) {
                    if (orderStatus.status === 'completed' && orderStatus.assignedTo.trim() === name) {
                      completedOrders.push(order);
                    } else if (orderStatus.status === 'ac_mgr') {
                      acMgrOrders.push(order);
                    } else if (orderStatus.status === 'awaiting') {
                      awaitingOrders.push(order);
                    } else {
                      inProgressOrders.push(order);
                    }
                  } else {
                    inProgressOrders.push(order);
                  }

                  const uniqueLines = new Set(rows.map(r => r['Line'])).size;
                  (uniqueLines <= 2 ? singleLine : multiLine).push(order);
                });

                const completionRate = uniqueUserOrders.length > 0 ? ((completedOrders.length / uniqueUserOrders.length) * 100).toFixed(1) : 0;
                const typeCountsFormatted = Object.keys(typeCounts).length > 0 ? Object.entries(typeCounts)
                  .map(([type, count]) => `${type}: ${count}`)
                  .join(', ') : 'No types found';

                const statusData = {
                  'Completed': completedOrders.length,
                  'In Progress': inProgressOrders.length,
                  'Awaiting': awaitingOrders.length,
                  'AC Mgr': acMgrOrders.length
                };
                const output = `
                  <div style="margin: 20px 0;">
                    <h3 style="color: var(--text-color); transition: color 0.3s ease;">📋 Individual Report: ${name}</h3>
                    <div class="stats">
                      <div class="stat-card">
                        <div class="stat-number"><span>${uniqueUserOrders.length}</span></div>
                        <div class="stat-label">Total Orders</div>
                      </div>
                      <div class="stat-card">
                        <div class="stat-number"><span>${completedOrders.length}</span></div>
                        <div class="stat-label">Completed</div>
                      </div>
                      <div class="stat-card">
                        <div class="stat-number"><span>${acMgrOrders.length}</span></div>
                        <div class="stat-label">AC Mgr Status</div>
                      </div>
                      <div class="stat-card">
                        <div class="stat-number"><span>${awaitingOrders.length}</span></div>
                        <div class="stat-label">Awaiting Response</div>
                      </div>
                      <div class="stat-card">
                        <div class="stat-number"><span>${completionRate}%</span></div>
                        <div class="stat-label">Completion Rate</div>
                      </div>
                    </div>
                    <div class="chart-container">
                      <h4 style="color: var(--text-color); transition: color 0.3s ease;">📈 Visual Summary</h4>
                      <div class="chart-row">
                        <div class="chart-wrapper">
                          <canvas id="summaryStatusChart"></canvas>
                        </div>
                        <div class="chart-wrapper">
                          <canvas id="summaryTypeChart"></canvas>
                        </div>
                      </div>
                    </div>
                    <div class="download-buttons">
                      <button onclick="downloadSummaryIndividualReport('${name}', 'excel')" class="export-btn">
                        ⬇️ Download Excel Report
                      </button>
                    </div>
                    <table>
                      <tr><th colspan="2">Detailed Summary for ${name}</th></tr>
                      <tr><td><strong>Total Unique Orders (Line 1 only)</strong></td><td>${uniqueUserOrders.length}</td></tr>
                      <tr><td><strong>Completed Orders</strong></td><td>${completedOrders.length}</td></tr>
                      <tr><td><strong>AC Mgr Status</strong></td><td>${acMgrOrders.length}</td></tr>
                      <tr><td><strong>Awaiting Response</strong></td><td>${awaitingOrders.length}</td></tr>
                      <tr><td><strong>In Progress</strong></td><td>${inProgressOrders.length}</td></tr>
                      <tr><td><strong>Single-line Orders (≤2 lines)</strong></td><td>${singleLine.length}</td></tr>
                      <tr><td><strong>Multi-line Orders (≥3 lines)</strong></td><td>${multiLine.length}</td></tr>
                      <tr><td><strong>Completion Rate</strong></td><td>${completionRate}%</td></tr>
                      <tr><td><strong>Order Types Distribution</strong></td><td>${typeCountsFormatted}</td></tr>
                    </table>
                  </div>`;
                document.getElementById('summaryOutput').innerHTML = output;
                renderSummaryCharts(name, statusData, typeCounts);
              } catch (error) {
                showSummaryMessage(`❌ Error generating report: ${error.message}`, 'error');
              }
            }

            async function downloadSummaryIndividualReport(name, format = 'excel') {
              showSummaryProcessing(true, `Preparing ${name}'s report...`);
              try {
                if (format === 'excel') {
                  const data = allSummaryData.filter(r => r['Assigned_To']?.trim() === name);
                  const ws = XLSX.utils.json_to_sheet(data);
                  const wb = XLSX.utils.book_new();
                  XLSX.utils.book_append_sheet(wb, ws, `${name}'s Orders`);
                  XLSX.writeFile(wb, `${name}_Orders_${new Date().toISOString().slice(0,10)}.xlsx`);
                }
                showSummaryProcessing(false);
                showSummaryMessage(`✅ Report for ${name} downloaded successfully!`, 'success');
              } catch (error) {
                showSummaryProcessing(false);
                showSummaryMessage(`❌ Error downloading report: ${error.message}`, 'error');
              }
            }

            async function generateSummaryExportAllUsers() {
              showSummaryProcessing(true);

              try {
                updateSummaryProgress(10, 'Analyzing orders...');
                await new Promise(resolve => setTimeout(resolve, 100));

                const result = {};
                allSummaryData.forEach(row => {
                  const order = row['Order#'];
                  if (!order || !row['Assigned_To']) return;
                  if (!result[order]) result[order] = [];
                  result[order].push(row);
                });

                updateSummaryProgress(20, 'Discovering all order types...');

                const allOrderTypes = new Set();
                allSummaryData.forEach(row => {
                  if (row['Type'] && typeof row['Type'] === 'string') {
                    const type = row['Type'].toString().trim().toUpperCase();
                    if (type) {
                      allOrderTypes.add(type);
                    }
                  }
                });

                const orderTypesArray = [...allOrderTypes].sort();
                showSummaryMessage(`ℹ️ Found ${orderTypesArray.length} unique order types: ${orderTypesArray.join(', ')}`, 'info');

                updateSummaryProgress(30, 'Processing user summaries...');
                const nameSummary = {};

                const orderStatusMap = {};
                allSummaryData.forEach(row => {
                  const order = row['Order#'];
                  if (!order) return;

                  const status = (row['Status'] || '').toString().toLowerCase();
                  const assigned = (row['Assigned_To'] || '').toString().trim();

                  if (!orderStatusMap[order]) {
                    orderStatusMap[order] = { status: 'in_progress', assignedTo: assigned };
                  }

                  if (status.includes('completed')) {
                    orderStatusMap[order] = { status: 'completed', assignedTo: assigned };
                  } else if (assigned.toLowerCase().includes('acmgr') || status.includes('ac mgr')) {
                    if (orderStatusMap[order].status !== 'completed') {
                      orderStatusMap[order] = { status: 'ac_mgr', assignedTo: assigned };
                    }
                  } else if (status.includes('awaiting')) {
                    if (!['completed', 'ac_mgr'].includes(orderStatusMap[order].status)) {
                      orderStatusMap[order] = { status: 'awaiting', assignedTo: assigned };
                    }
                  }
                });

                Object.entries(result).forEach(([order, rows]) => {
                  const line1 = rows.find(r => parseInt(r['Line']) === 1);
                  if (!line1 || !line1['Assigned_To']) return;

                  const name = line1['Assigned_To'].toString().trim();
                  const orderStatus = orderStatusMap[order];

                  if (orderStatus &&
                      ['completed', 'ac_mgr'].includes(orderStatus.status) &&
                      orderStatus.assignedTo.trim() !== name) {
                    return;
                  }

                  if (!nameSummary[name]) {
                    nameSummary[name] = {
                      Name: name,
                      Total: 0,
                      Completed: 0,
                      'AC Mgr': 0,
                      Awaiting: 0,
                      'In Progress': 0,
                      Single: 0,
                      Multi: 0,
                      'Completion Rate': '0%'
                    };

                    orderTypesArray.forEach(type => {
                      nameSummary[name][type] = 0;
                    });
                  }

                  nameSummary[name].Total++;

                  if (orderStatus) {
                    if (orderStatus.status === 'completed' && orderStatus.assignedTo.trim() === name) {
                      nameSummary[name].Completed++;
                    } else if (orderStatus.status === 'ac_mgr') {
                      nameSummary[name]['AC Mgr']++;
                    } else if (orderStatus.status === 'awaiting') {
                      nameSummary[name].Awaiting++;
                    } else {
                      nameSummary[name]['In Progress']++;
                    }
                  } else {
                    nameSummary[name]['In Progress']++;
                  }

                  const uniqueLines = new Set(rows.map(r => r['Line'])).size;
                  uniqueLines <= 2 ? nameSummary[name].Single++ : nameSummary[name].Multi++;
                  if (line1['Type']) {
                    const type = line1['Type'].toString().trim().toUpperCase();
                    if (nameSummary[name][type] !== undefined) {
                      nameSummary[name][type]++;
                    }
                  }
                });

                updateSummaryProgress(60, 'Calculating completion rates...');

                Object.values(nameSummary).forEach(summary => {
                  if (summary.Total > 0) {
                    const rate = ((summary.Completed / summary.Total) * 100).toFixed(1);
                    summary['Completion Rate'] = rate + '%';
                  }
                });

                updateSummaryProgress(70, 'Creating detailed order data...');

                const detailedData = [];
                Object.entries(result).forEach(([order, rows]) => {
                  const line1 = rows.find(r => parseInt(r['Line']) === 1);
                  if (!line1 || !line1['Assigned_To']) return;

                  const name = line1['Assigned_To'].toString().trim();
                  const orderStatus = orderStatusMap[order];

                  if (orderStatus &&
                      ['completed', 'ac_mgr'].includes(orderStatus.status) &&
                      orderStatus.assignedTo.trim() !== name) {
                    return;
                  }

                  let finalStatus = 'In Progress';
                  if (orderStatus) {
                    if (orderStatus.status === 'completed' && orderStatus.assignedTo.trim() === name) {
                      finalStatus = 'Completed';
                    } else if (orderStatus.status === 'ac_mgr') {
                      finalStatus = 'AC Mgr';
                    } else if (orderStatus.status === 'awaiting') {
                      finalStatus = 'Awaiting';
                    }
                  }

                  detailedData.push({
                    'Order#': order,
                    'Assigned To': name,
                    'Final Status': finalStatus,
                    'Order Type': line1['Type'] || '',
                    'Line Count': rows.length
                  });
                });

                updateSummaryProgress(80, 'Generating Excel file...');
                await new Promise(resolve => setTimeout(resolve, 200));

                const exportData = Object.values(nameSummary).sort((a, b) => a.Name.localeCompare(b.Name));

                const workbook = XLSX.utils.book_new();

                const summarySheet = XLSX.utils.json_to_sheet(exportData);
                const summaryColWidths = Object.keys(exportData[0] || {}).map(key => ({
                  wch: Math.max(key.length, 12)
                }));
                summarySheet['!cols'] = summaryColWidths;
                XLSX.utils.book_append_sheet(workbook, summarySheet, 'User Summary');

                const detailedSheet = XLSX.utils.json_to_sheet(detailedData);
                const detailedColWidths = Object.keys(detailedData[0] || {}).map(key => ({
                  wch: Math.max(key.length, 15)
                }));
                detailedSheet['!cols'] = detailedColWidths;
                XLSX.utils.book_append_sheet(workbook, detailedSheet, 'Detailed Orders');

                const typesSummary = {};
                orderTypesArray.forEach(type => {
                  typesSummary[type] = {
                    'Order Type': type,
                    'Total Count': 0,
                    'Users': []
                  };
                });

                Object.values(nameSummary).forEach(user => {
                  orderTypesArray.forEach(type => {
                    if (user[type] > 0) {
                      typesSummary[type]['Total Count'] += user[type];
                      typesSummary[type]['Users'].push(`${user.Name} (${user[type]})`);
                    }
                  });
                });

                const typesData = Object.values(typesSummary).map(item => ({
                  'Order Type': item['Order Type'],
                  'Total Count': item['Total Count'],
                  'Assigned Users': item['Users'].join('; ')
                })).sort((a, b) => b['Total Count'] - a['Total Count']);

                const typesSheet = XLSX.utils.json_to_sheet(typesData);
                typesSheet['!cols'] = [
                  { wch: 15 },
                  { wch: 12 },
                  { wch: 50 }
                ];
                XLSX.utils.book_append_sheet(workbook, typesSheet, 'Order Types Summary');

                updateSummaryProgress(95, 'Saving file...');
                const fileName = `Complete_Order_Analysis_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(workbook, fileName);

                updateSummaryProgress(100, 'Export complete!', `Generated: ${fileName} with ${exportData.length} users and ${detailedData.length} orders`);

                setTimeout(() => {
                  showSummaryProcessing(false);
                  showSummaryMessage(`✅ Complete Excel file exported: ${fileName}<br>
                                      📊 Includes: User Summary, Detailed Orders, and Order Types Summary<br>
                                      📈 ${exportData.length} users, ${detailedData.length} orders, ${orderTypesArray.length} order types`, 'success');
                }, 500);

              } catch (error) {
                showSummaryProcessing(false);
                showSummaryMessage(`❌ Error generating export: ${error.message}`, 'error');
              }
            }

            async function generateSummaryStatusWiseReport() {
              showSummaryProcessing(true, 'Compiling final-status-wise order report...');

              try {
                const statusBuckets = {
                  Completed: [],
                  'AC Mgr': [],
                  Awaiting: [],
                  'In Progress': []
                };

                const orderMap = {};
                const orderStatusMap = {};

                allSummaryData.forEach(row => {
                  const order = row['Order#'];
                  if (!order) return;

                  const status = (row['Status'] || '').toLowerCase();
                  const assigned = (row['Assigned_To'] || '').trim();

                  if (!orderMap[order]) orderMap[order] = [];
                  orderMap[order].push(row);

                  if (!orderStatusMap[order]) {
                    orderStatusMap[order] = { status: 'in_progress', assignedTo: assigned };
                  }

                  if (status.includes('completed')) {
                    orderStatusMap[order] = { status: 'completed', assignedTo: assigned };
                  } else if (assigned.toLowerCase().includes('acmgr') || status.includes('ac mgr')) {
                    if (orderStatusMap[order].status !== 'completed') {
                      orderStatusMap[order] = { status: 'ac_mgr', assignedTo: assigned };
                    }
                  } else if (status.includes('awaiting')) {
                    if (!['completed', 'ac_mgr'].includes(orderStatusMap[order].status)) {
                      orderStatusMap[order] = { status: 'awaiting', assignedTo: assigned };
                    }
                  }
                });

                Object.entries(orderMap).forEach(([order, rows]) => {
                  const line1 = rows.find(r => parseInt(r['Line']) === 1);
                  if (!line1 || !line1['Assigned_To']) return;

                  const name = line1['Assigned_To'].trim();
                  const final = orderStatusMap[order];
                  if (!final) return;

                  if (['completed', 'ac_mgr'].includes(final.status) && final.assignedTo !== name) return;

                  const finalStatus = {
                    completed: 'Completed',
                    ac_mgr: 'AC Mgr',
                    awaiting: 'Awaiting',
                    in_progress: 'In Progress'
                  }[final.status];

                  const outputRow = {
                    'Order#': order,
                    'Assigned To': name,
                    'Final Status': finalStatus,
                    'Order Type': line1['Type'] || '',
                    'Line Count': rows.length
                  };

                  statusBuckets[finalStatus].push(outputRow);
                });

                const wb = XLSX.utils.book_new();
                Object.entries(statusBuckets).forEach(([status, rows]) => {
                  const sheet = XLSX.utils.json_to_sheet(rows);
                  sheet['!cols'] = [
                    { wch: 15 }, { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 12 }
                  ];
                  XLSX.utils.book_append_sheet(wb, sheet, `${status} Orders`);
                });

                const filename = `StatusWise_Order_Report_${new Date().toISOString().slice(0, 10)}.xlsx`;
                XLSX.writeFile(wb, filename);

                showSummaryProcessing(false);
                showSummaryMessage(`✅ Downloaded status-wise final order report: ${filename}`, 'success');
              } catch (error) {
                showSummaryProcessing(false);
                showSummaryMessage(`❌ Error generating report: ${error.message}`, 'error');
              }
            }


            function handleSummaryExport() {
              const selectedType = document.getElementById('summaryExportTypeSelector').value;

              if (selectedType === 'all') {
                generateSummaryExportAllUsers();
              } else if (selectedType === 'status') {
                generateSummaryStatusWiseReport();
              } else {
                showSummaryMessage('❗Please select a valid report type from the dropdown.', 'error');
              }
            }

            function renderSummaryTopPerformers() {
                if (allSummaryData.length === 0) {
                    document.getElementById('summaryTopPerformers').style.display = 'none';
                    return;
                }

                const performerStats = {};

                const orderMap = {};
                const orderStatusMap = {};

                allSummaryData.forEach(row => {
                    const order = row['Order#'];
                    if (!order) return;
                    const status = (row['Status'] || '').toString().toLowerCase();
                    const assigned = (row['Assigned_To'] || '').toString().trim();
                    if (!orderMap[order]) orderMap[order] = [];
                    orderMap[order].push(row);

                    if (!orderStatusMap[order]) {
                        orderStatusMap[order] = { status: 'in_progress', assignedTo: assigned };
                    }
                    if (status.includes('completed')) {
                        orderStatusMap[order] = { status: 'completed', assignedTo: assigned };
                    } else if (assigned.toLowerCase().includes('acmgr') || status.includes('ac mgr')) {
                        if (orderStatusMap[order].status !== 'completed') {
                            orderStatusMap[order] = { status: 'ac_mgr', assignedTo: assigned };
                        }
                    } else if (status.includes('awaiting')) {
                        if (!['completed', 'ac_mgr'].includes(orderStatusMap[order].status)) {
                            orderStatusMap[order] = { status: 'awaiting', assignedTo: assigned };
                        }
                    }
                });

                for (const orderId in orderMap) {
                    const rowsForOrder = orderMap[orderId];
                    const line1Row = rowsForOrder.find(r => parseInt(r['Line']) === 1);

                    if (!line1Row || !line1Row['Assigned_To']) continue;

                    const assigneeName = line1Row['Assigned_To'].toString().trim();
                    const orderStatus = orderStatusMap[orderId];

                    if (!performerStats[assigneeName]) {
                        performerStats[assigneeName] = { totalOrders: 0, completedOrders: 0 };
                    }

                    const shouldCountForAssignee = !orderStatus ||
                                                   orderStatus.assignedTo.trim() === assigneeName ||
                                                   !['completed', 'ac_mgr'].includes(orderStatus.status);

                    if (shouldCountForAssignee) {
                        performerStats[assigneeName].totalOrders++;

                        if (orderStatus && orderStatus.status === 'completed' && orderStatus.assignedTo.trim() === assigneeName) {
                            performerStats[assigneeName].completedOrders++;
                        }
                    }
                }

                const performers = Object.entries(performerStats)
                    .map(([name, stats]) => ({
                        name: name,
                        completed: stats.completedOrders,
                        totalOrders: stats.totalOrders,
                        completionRate: stats.totalOrders > 0 ? (stats.completedOrders / stats.totalOrders) * 100 : 0
                    }))
                    .sort((a, b) => b.completed - a.completed);

                const leaderboardContainer = document.getElementById('summaryLeaderboardContainer');
                leaderboardContainer.innerHTML = '';

                if (performers.length === 0) {
                    document.getElementById('summaryTopPerformers').style.display = 'none';
                    return;
                }

                // Define distinct colors for top 5 performers based on the new request
                const performerColors = [
                    'var(--performer-1-bg)', /* #1 Green */
                    'var(--performer-2-bg)', /* #2 Light Green */
                    'var(--performer-3-bg)', /* #3 Yellow */
                    'var(--performer-4-bg)', /* #4 Gold/Orange-Yellow */
                    'var(--performer-5-bg)'  /* #5 Deeper Orange */
                ];

                performers.slice(0, 5).forEach((p, index) => {
                    const backgroundColor = performerColors[index] || 'var(--card-bg)'; // Fallback if more than 5
                    leaderboardContainer.innerHTML += `
                    <div class="stat-card" style="background: ${backgroundColor}; color: white;">
                        <div class="stat-number"><span>#${index + 1}</span></div>
                        <div class="stat-label">${p.name}</div>
                        <div style="font-size: 14px; margin-top: 5px;">${p.completed} Completed</div>
                        <div style="font-size: 11px; margin-top: 2px;">(${p.totalOrders} Total)</div>
                        <div style="font-size: 9px; opacity: 0.8;">(${p.completionRate.toFixed(1)}% rate)</div>
                    </div>
                    `;
                });
                const tp = document.getElementById('summaryTopPerformers');
                tp.style.display = 'block';
                setTimeout(() => tp.classList.add('show'), 50);
            }


            function searchSummaryReportByName() {
              const nameInput = document.getElementById('summaryNameInput');
              const selectedName = nameInput.value.trim();

              if (!selectedName) {
                showSummaryMessage('Please type a name to search.', 'error');
                return;
              }

              const nameSet = new Set(
                allSummaryData
                  .map(r => r['Assigned_To'])
                  .filter(name => name && typeof name === 'string' && name.trim())
                  .map(name => name.trim())
              );

              if (nameSet.has(selectedName)) {
                generateSummaryReport(selectedName);
              } else {
                showSummaryMessage(`No report found for "${selectedName}". Please ensure the name is exactly as it appears in the data.`, 'error');
                document.getElementById('summaryOutput').innerHTML = '';
              }
            }

            function clearSummaryReportSearch() {
              document.getElementById('summaryNameInput').value = '';
              document.getElementById('summaryOutput').innerHTML = '';
              clearSummaryMessages();
              hideAllSummaryOutputs(); // Hide all outputs
              if (allSummaryData.length > 0) {
                 document.getElementById('summaryTopPerformers').style.display = 'block'; // Show top performers again
              }
            }

            function resetSummaryTool() {
                allSummaryData = [];
                document.getElementById('summaryFileInput').value = '';
                document.getElementById('summaryManualInput').value = '';
                document.getElementById('summaryMessages').innerHTML = '';
                document.getElementById('summaryProcessing').style.display = 'none';
                document.getElementById('summaryControls').style.display = 'none';
                
                hideAllSummaryOutputs(); // Ensure all output sections are hidden

                document.getElementById('summaryNameInput').value = '';
                document.getElementById('summaryNameSuggestions').innerHTML = '';
                document.getElementById('summaryFileNameDisplay').textContent = ''; // Clear file display

                if (window.summaryStatusChart instanceof Chart) {
                    window.summaryStatusChart.destroy();
                }
                if (window.summaryTypeChart instanceof Chart) {
                    window.summaryTypeChart.destroy();
                }
                if (window.dailyOrderCountChart instanceof Chart) {
                    window.dailyOrderCountChart.destroy();
                }
                if (window.dailyCompletionRateChart instanceof Chart) {
                    window.dailyCompletionRateChart.destroy();
                }
            }

            // Function to hide all summary output sections
            function hideAllSummaryOutputs() {
                document.getElementById('summaryOutput').style.display = 'none';
                document.getElementById('summaryTopPerformers').style.display = 'none';
                document.getElementById('summaryTrendCharts').style.display = 'none';
                document.getElementById('summaryPeakPerformance').style.display = 'none';
            }

            // Function to show time-based trends and hide others
            function showTimeBasedTrends() {
                if (allSummaryData.length === 0) {
                    showSummaryMessage('Please process your order data first to view trends.', 'info');
                    return;
                }

                hideAllSummaryOutputs(); // Hide all other sections first
                
                document.getElementById('summaryTrendCharts').style.display = 'block';
                document.getElementById('summaryPeakPerformance').style.display = 'block';

                renderSummaryTrendCharts();
                renderPeakPerformanceAnalysis();
                showSummaryMessage('📈 Displaying time-based order trends and peak performance insights.', 'info');
            }


            // Drag and Drop functionality for Summary Tool
            document.addEventListener('DOMContentLoaded', () => {
                const uploadArea = document.getElementById('summaryUploadArea');
                const fileInput = document.getElementById('summaryFileInput');
                const fileNameDisplay = document.getElementById('summaryFileNameDisplay');
                const manualInput = document.getElementById('summaryManualInput');

                if (uploadArea && fileInput && fileNameDisplay && manualInput) {
                    // Prevent default drag behaviors
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, preventDefaults, false);
                    });

                    // Highlight drop zone when item is dragged over
                    ['dragenter', 'dragover'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, () => uploadArea.classList.add('drag-over'), false);
                    });

                    ['dragleave', 'drop'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('drag-over'), false);
                    });

                    // Handle dropped files
                    uploadArea.addEventListener('drop', handleDrop, false);

                    // Handle file selection via input click
                    fileInput.addEventListener('change', handleFileSelect, false);

                    function preventDefaults(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    function handleDrop(e) {
                        const dt = e.dataTransfer;
                        const files = dt.files;
                        if (files.length > 0) {
                            fileInput.files = files; // Assign the dropped files to the input
                            updateSummaryFileNameDisplay(files[0].name);
                        }
                    }

                    function handleFileSelect(e) {
                        const files = e.target.files;
                        if (files.length > 0) {
                            updateSummaryFileNameDisplay(files[0].name);
                        } else {
                            updateSummaryFileNameDisplay('');
                        }
                    }

                    function updateSummaryFileNameDisplay(name) {
                        if (name) {
                            fileNameDisplay.textContent = `File selected: "${name}".`;
                            manualInput.value = ''; // Clear manual input if a file is selected
                        } else {
                            fileNameDisplay.textContent = '';
                        }
                    }

                    // Clear file input display when manual input is typed into
                    manualInput.addEventListener('input', () => {
                        if (manualInput.value.trim() !== '') {
                            fileInput.value = ''; // Clear selected file
                            updateSummaryFileNameDisplay('');
                        }
                    });
                }
            });
        </script>
    </div>

    <!-- Order Validation Tool Section -->
    <div id="validationTool" class="tool-container validator-tool" style="display: none;">
        <button onclick="showOptions()" class="back-to-options-btn">← Back to Options</button>
        <!-- Dark Mode Toggle (now global and positioned within the tool) -->
        <button id="validatorDarkModeToggle" class="global-dark-mode-toggle">🌙 Dark Mode</button>
        <div class="container container-validator" style="box-shadow: none;"> <!-- remove duplicate shadow -->
            <h1>✅ ValidatorPro</h1>
            <div class="input-section" id="validationInputSection">
                <h3>Upload or Paste Data</h3>
                <div class="upload-area" id="uploadAreaValidator">
                    <p style="font-size: 1.1em; color: var(--text-color); margin-bottom: 20px;">
                        Drag & drop your Excel (.xlsx, .xls) or CSV file here, or click to upload.
                    </p>
                    <input type="file" id="fileUpload" accept=".xlsx,.xls,.csv" class="file-input-hidden">
                    <button type="button" class="drop-zone-button" onclick="document.getElementById('fileUpload').click()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-upload-cloud"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></svg>
                        Choose File
                    </button>
                    <div id="fileNameDisplay" class="file-name-display"></div> <!-- Added for file name display -->
                    <div class="separator">— OR —</div>
                    <textarea id="csvInput" rows="8" placeholder="Paste CSV or tab-separated data here (ensure header row is included)&#10;&#10;Expected columns: Order#, Assigned_To, Status, Start, End, Reason for Pending, Batch Time"></textarea>
                    
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px;">
                    <button onclick="triggerAnalysis()">🔍 Analyze Data</button>
                    <button onclick="downloadErrorsAsCSV()">⬇️ Download Errors</button>
                    <button onclick="resetTool()">🔄 Reset</button>
                    <button onclick="toggleDebugInfo()">🐞 Toggle Debug Info</button>
                </div>
            </div>


            <div class="processing" id="spinner" style="display: none;">
                <div class="spinner"></div>
                <div>
                    <div id="spinner-text">⏳ Analyzing data...</div>
                    <p id="analyzeTime" style="margin: 0; font-weight: bold; color: var(--success-text);"></p>
                </div>
            </div>

            <div id="debugInfo" class="debug-info" style="display: none;">
                <h4 style="color: var(--text-color);">Debug Information:</h4>
                <div id="debugContent" style="font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; background: var(--input-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--input-border); overflow-x: auto;"></div>
            </div>

            <div id="errorSection" style="display: none;">
                <h3 style="color: var(--text-color);">Error Report:</h3>
                <table id="errorTable">
                    <thead>
                        <tr><th>Row (Original)</th><th>Order#</th><th>Assigned_To</th><th>Error Message</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <footer class="footer-validator">
            <p>✦ Created by Saikat Majumder © 2025</p>
        </footer>

        <script>
            let parsedData = [];
            let errorLog = [];
            let worker = null;
            let workerStartTime;
            let debugMode = false;
            const expectedValidationColumns = ['Order#', 'Assigned_To', 'Status', 'Start', 'End', 'Reason for Pending', 'Batch Time'];

            // --- Web Worker Code as a String (This content runs in a background thread) ---
            const workerCode = `
              function parseTime(timeString) {
                  if (!timeString || typeof timeString !== 'string' || timeString.trim() === "") return null;
                  timeString = timeString.trim();

                  let cleanTimeString = timeString.toUpperCase();
                  let parsedDate = null;

                  let parts = cleanTimeString.match(/^(\\d{1,2}):(\\d{2}):(\\d{2})$/);
                  if (parts) {
                      parsedDate = new Date(1970, 0, 1, parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10));
                  } else {
                      parts = cleanTimeString.match(/^(\\d{1,2}):(\\d{2})(?:\\s*(AM|PM))?.*$/);
                      if (parts) {
                          let hours = parseInt(parts[1], 10);
                          let minutes = parseInt(parts[2], 10);
                          let meridiem = parts[3];

                          if (meridiem === 'PM' && hours < 12) hours += 12;
                          if (meridiem === 'AM' && hours === 12) hours = 0;

                          parsedDate = new Date(1970, 0, 1, hours, minutes, 0);
                      }
                  }
                  return (parsedDate && !isNaN(parsedDate.getTime())) ? parsedDate : null;
              }

              function applyBatchTimeRules(data, errorLog) {
                  const grouped = {};
                  data.forEach(row => {
                      const orderNo = String(row['Order#'] || '').trim();
                      const assignee = String(row['Assigned_To'] || '').trim();
                      const status = String(row['Status'] || '').trim();
                      const batchTimeRaw = String(row['Batch Time'] || '').trim();

                      if (!orderNo || !assignee) return;

                      const key = \`\${orderNo}_\${assignee}\`;
                      if (!grouped[key]) {
                          grouped[key] = {
                              statuses: new Set(),
                              batchTimes: new Set(),
                              rows: []
                          };
                      }
                      if (status) grouped[key].statuses.add(status);

                      const parsedBatchTime = parseTime(batchTimeRaw);
                      if (parsedBatchTime) {
                          grouped[key].batchTimes.add(
                              [parsedBatchTime.getHours(), parsedBatchTime.getMinutes(), parsedBatchTime.getSeconds()]
                                  .map(n => n.toString().padStart(2, '0')).join(':')
                          );
                      }
                      grouped[key].rows.push(row);
                  });

                  for (const key in grouped) {
                      const group = grouped[key];
                      const [orderNo, assignee] = key.split('_');

                      const uniqueStatuses = Array.from(group.statuses);
                      const uniqueBatchTimes = Array.from(group.batchTimes);

                      if (uniqueStatuses.length > 1) {
                          if (uniqueBatchTimes.length <= 1) {
                              errorLog.push({
                                  row: group.rows.map(r => r._originalRowIndex).join(', '),
                                  order: orderNo,
                                  assignee: assignee,
                                  message: "Batch time did not change when order status changed across entries for this Order#/Assignee combination."
                              });
                          }
                      } else if (uniqueStatuses.length === 1) {
                          if (uniqueBatchTimes.length > 1) {
                              errorLog.push({
                                  row: group.rows.map(r => r._originalRowIndex).join(', '),
                                  order: orderNo,
                                  assignee: assignee,
                                  message: "Batch time changed when order status remained the same for this Order#/Assignee combination."
                              });
                          }
                      }
                  }
              }

              function applyRowLevelValidationRules(data, errorLog) {
                data.forEach(row => {
                  const orderNo = String(row['Order#'] || '').trim();
                  const assignee = String(row['Assigned_To'] || '').trim();
                  const originalRowIndex = row._originalRowIndex;

                  const status = String(row['Status'] || '').trim();
                  const startTimeValue = String(row['Start'] || '').trim();
                  const endTimeValue = String(row['End'] || '').trim();
                  const reasonForPending = String(row['Reason for Pending'] || '').trim();

                  const startTime = parseTime(startTimeValue);
                  const endTime = parseTime(endTimeValue);
                  if (startTime && endTime) {
                    if (endTime < startTime) {
                      errorLog.push({
                        row: originalRowIndex,
                        order: orderNo,
                        assignee: assignee,
                        message: \`End time (\${endTimeValue}) is earlier than Start time (\${startTimeValue}).\`
                      });
                    }
                  }

                  if (!status) return;

                  if (['Awaiting response', 'Completed'].includes(status)) {
                      if (startTimeValue === "" || endTimeValue === "") {
                          errorLog.push({
                              row: originalRowIndex,
                              order: orderNo,
                              assignee: assignee,
                              message: \`Status is '\${status}', but Start or End time is blank.\`
                          });
                      }
                  } else if (['On hold', 'AcMgr'].includes(status)) {
                      if (startTimeValue !== "" || endTimeValue !== "") {
                          errorLog.push({
                              row: originalRowIndex,
                              order: orderNo,
                              assignee: assignee,
                              message: \`Status is '\${status}', but Start or End time is not blank.\`
                          });
                      }
                  }

                  if (['Awaiting response', 'AcMgr'].includes(status)) {
                      if (reasonForPending === "") {
                          errorLog.push({
                              row: originalRowIndex,
                              order: orderNo,
                              assignee: assignee,
                              message: \`Status is '\${status}', but 'Reason for Pending' is blank.\`
                          });
                      }
                  } else if (['Completed', 'On hold'].includes(status)) {
                      if (reasonForPending !== "") {
                          errorLog.push({
                              row: originalRowIndex,
                              order: orderNo,
                              assignee: assignee,
                              message: \`Status is '\${status}', but 'Reason for Pending' is not blank.\`
                          });
                      }
                  }
                });
              }

              self.onmessage = function(e) {
                  const { data } = e;
                  const errorLog = [];

                  applyBatchTimeRules(data, errorLog);
                  applyRowLevelValidationRules(data, errorLog);

                  self.postMessage(errorLog);
              };
            `;

            function initWorker() {
                if (worker) {
                    worker.terminate();
                    worker = null;
                }
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const blobURL = URL.createObjectURL(blob);
                worker = new Worker(blobURL);

                worker.onmessage = function(e) {
                    const end = performance.now();
                    errorLog = e.data;

                    displayErrors(errorLog);

                    document.getElementById('spinner').style.display = 'none';
                    document.getElementById('analyzeTime').innerText = `Analyzed in ${(end - workerStartTime).toFixed(2)} ms. Found ${errorLog.length} errors.`;
                    URL.revokeObjectURL(blobURL);
                };

                worker.onerror = function(error) {
                    console.error('Web Worker error:', error);
                    document.getElementById('spinner').style.display = 'none';
                    showCustomMessageBox(`
                        <strong>Error during analysis:</strong> An unexpected issue occurred in the background. This might be due to unexpected data format or missing critical columns (Order#, Assigned_To, Status, Start, End, Batch Time, Reason for Pending).
                        <br><br>Please check the browser console (F12) for more technical details.
                    `, 'error');
                    URL.revokeObjectURL(blobURL);
                };
            }

            function showCustomMessageBox(message, type = 'info') {
                let messageBox = document.getElementById('customMessageBox');
                if (!messageBox) {
                    messageBox = document.createElement('div');
                    messageBox.id = 'customMessageBox';
                    messageBox.className = 'message-box-custom';
                    document.body.appendChild(messageBox);
                }
                messageBox.innerHTML = `
                    <div class="${type}">
                        ${message}
                        <button onclick="document.getElementById('customMessageBox').remove()">Close</button>
                    </div>
                `;
                messageBox.className = `message-box-custom ${type}`;
            }


            async function triggerAnalysis() {
                workerStartTime = performance.now();
                document.getElementById('spinner').style.display = 'flex';
                document.getElementById('analyzeTime').innerText = '';
                // Ensure error section is visible when analysis starts
                document.getElementById('errorSection').style.display = 'block';
                displayErrors([]); // Clear previous errors and show "No errors found" temporarily

                const fileInput = document.getElementById('fileUpload');
                const csvInput = document.getElementById('csvInput');
                let dataRaw = [];

                try {
                    if (fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const fileName = file.name.toLowerCase();

                        const reader = new FileReader();
                        reader.onload = function (evt) {
                            if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                                const data = new Uint8Array(evt.target.result);
                                const workbook = XLSX.read(data, { type: 'array' });
                                const sheetName = workbook.SheetNames[0];
                                dataRaw = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1, raw: false });
                            } else if (fileName.endsWith('.csv')) {
                                dataRaw = Papa.parse(evt.target.result, { header: false }).data;
                            } else {
                                showCustomMessageBox('<strong>Unsupported File Type:</strong> Please upload an XLSX, XLS, or CSV file.', 'info');
                                document.getElementById('spinner').style.display = 'none';
                                document.getElementById('errorSection').style.display = 'none'; // Hide if error
                                return;
                            }
                            processParsedDataValidation(dataRaw);
                        };

                        if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                            reader.readAsArrayBuffer(file);
                        } else if (fileName.endsWith('.csv')) {
                            reader.readAsText(file);
                        }

                    } else if (csvInput.value.trim() !== "") {
                        let cleanedCsvText = csvInput.value.replace(/\u00A0/g, ' ').replace(/\n{2,}/g, '\n').trim();
                        const parseResult = Papa.parse(cleanedCsvText, {
                            header: false,
                            skipEmptyLines: true,
                            dynamicTyping: false,
                            delimiter: cleanedCsvText.includes('\t') ? '\t' : ''
                        });
                        dataRaw = parseResult.data;
                        if (parseResult.errors.length > 0) {
                            console.warn("Papa Parse Errors:", parseResult.errors);
                            showCustomMessageBox('<strong>Warning:</strong> Some issues detected during data parsing from pasted text. Data might be malformed.', 'info');
                        }
                        processParsedDataValidation(dataRaw);
                    } else {
                        showCustomMessageBox('<strong>No Data:</strong> Please upload a file or paste data in the text area.', 'info');
                        document.getElementById('spinner').style.display = 'none';
                        document.getElementById('errorSection').style.display = 'none'; // Hide if no data
                    }
                } catch (error) {
                    document.getElementById('spinner').style.display = 'none';
                    showCustomMessageBox(`<strong>Error during data input:</strong> ${error.message}`, 'error');
                }
            }

            function processParsedDataValidation(dataRaw) {
                if (dataRaw.length === 0 || (dataRaw.length === 1 && dataRaw[0].length === 0)) {
                    showCustomMessageBox('<strong>Empty Data:</strong> No data found to analyze. Please ensure your file or pasted data contains content.', 'info');
                    document.getElementById('spinner').style.display = 'none';
                    document.getElementById('errorSection').style.display = 'none'; // Hide if empty
                    return;
                }

                const headers = dataRaw[0].map(h => String(h).trim());
                const rawDataRows = dataRaw.slice(1);

                parsedData = rawDataRows.map((row, index) => {
                    const obj = { _originalRowIndex: index + 2 };
                    headers.forEach((header, i) => {
                        obj[header] = row[i] !== undefined && row[i] !== null ? String(row[i]).trim() : '';
                    });
                    return obj;
                });

                parsedData = cleanAndNormalizeValidationData(parsedData); // Apply cleaning here

                const requiredColumns = ['Order#', 'Assigned_To', 'Status', 'Start', 'End', 'Reason for Pending', 'Batch Time'];
                const availableColumns = Object.keys(parsedData[0] || {});
                const missingColumns = requiredColumns.filter(col => !availableColumns.includes(col));

                if (missingColumns.length > 0) {
                    showCustomMessageBox(`<strong>Missing Columns:</strong> The following required columns are missing from your data: ${missingColumns.join(', ')}. Please ensure they are present and correctly spelled in your header row.`, 'error');
                    document.getElementById('spinner').style.display = 'none';
                    document.getElementById('errorSection').style.display = 'none'; // Hide if missing columns
                    return;
                }

                updateDebugInfo();

                if (worker) {
                    worker.postMessage(parsedData);
                } else {
                    showCustomMessageBox('<strong>Initialization Error:</strong> The validation tool could not start. Please try refreshing the page.', 'error');
                    document.getElementById('spinner').style.display = 'none';
                    document.getElementById('errorSection').style.display = 'none'; // Hide if worker error
                }
            }


            function displayErrors(errors) {
              const tbody = document.querySelector("#errorTable tbody");
              tbody.innerHTML = "";
              if (errors.length === 0) {
                tbody.insertAdjacentHTML("beforeend", '<tr><td colspan="4" style="text-align: center;">✨ No errors found!</td></tr>');
                return;
              }
              errors.forEach(error => {
                const row = `<tr><td>${error.row}</td><td>${error.order || ''}</td><td>${error.assignee || ''}</td><td>${error.message}</td></tr>`;
                tbody.insertAdjacentHTML("beforeend", row);
              });
            }

            function downloadErrorsAsCSV() {
              if (!errorLog.length) {
                showCustomMessageBox('<strong>No Errors:</strong> There are no errors to download.', 'info');
                return;
              }
              const csv = ["Row (Original),Order#,Assigned_To,Error Message"];
              errorLog.forEach(e => csv.push(`"${e.row}","${(e.order || '').replace(/"/g, '""')}","${(e.assignee || '').replace(/"/g, '""')}","${(e.message || '').replace(/"/g, '""')}"`));
              const blob = new Blob([csv.join("\n")], { type: "text/csv;charset=utf-8;" });
              const link = document.createElement("a");
              link.href = URL.createObjectURL(blob);
              link.download = "order_validation_errors.csv";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(link.href);
            }

            function resetTool() {
              parsedData = [];
              errorLog = [];
              document.getElementById("fileUpload").value = "";
              document.getElementById("csvInput").value = "";
              document.querySelector("#errorTable tbody").innerHTML = "";
              document.getElementById("analyzeTime").innerText = "";
              document.getElementById('spinner').style.display = 'none';
              document.getElementById('errorSection').style.display = 'none'; // Hide on reset
              document.getElementById('fileNameDisplay').textContent = ''; // Clear file display
              updateDebugInfo();
              initWorker(); // Re-initialize worker on reset
            }

            // Centralized cleaning function for validation tool
            function cleanAndNormalizeValidationData(data) {
              // Deep copy to ensure original data is not modified
              let cleanedData = JSON.parse(JSON.stringify(data));

              // Trim all cell values
              cleanedData = cleanedData.map(row => {
                  const newRow = {};
                  for (const key in row) {
                      newRow[key] = typeof row[key] === 'string' ? row[key].trim() : row[key];
                  }
                  return newRow;
              });

              // Remove empty rows (rows where all values are empty strings)
              cleanedData = cleanedData.filter(row => {
                  return Object.values(row).some(val => val !== null && val !== undefined && String(val).trim() !== '');
              });

              // Remove empty columns (columns where all values are empty strings)
              if (cleanedData.length > 0) {
                  const allColumns = Object.keys(cleanedData[0]);
                  const columnsToKeep = allColumns.filter(col =>
                      cleanedData.some(row => row[col] !== null && row[col] !== undefined && String(row[col]).trim() !== '')
                  );
                  cleanedData = cleanedData.map(row => {
                      const newRow = {};
                      columnsToKeep.forEach(col => {
                          newRow[col] = row[col];
                      });
                      return newRow;
                  });
              }

              return cleanedData;
            }

            function toggleDebugInfo() {
              debugMode = !debugMode;
              const debugDiv = document.getElementById('debugInfo');
              debugDiv.style.display = debugMode ? 'block' : 'none';
              updateDebugInfo();
            }

            function updateDebugInfo() {
              if (!debugMode) return;
              
              const debugContent = document.getElementById('debugContent');
              if (parsedData.length > 0) {
                const sample = parsedData[0];
                const columns = Object.keys(sample);
                
                const stats = {
                  totalRows: parsedData.length,
                  emptyRows: parsedData.filter(row => Object.values(row).every(val => val === '')).length,
                  orderNumbers: new Set(parsedData.map(row => row['Order#']).filter(val => val)).size,
                  assignees: new Set(parsedData.map(row => row['Assigned_To']).filter(val => val)).size,
                  statuses: new Set(parsedData.map(row => row['Status']).filter(val => val)),
                };
                
                debugContent.innerHTML = `
                  <strong>Data loaded:</strong> ${stats.totalRows} rows<br>
                  <strong>Empty rows:</strong> ${stats.emptyRows}<br>
                  <strong>Unique Order#:</strong> ${stats.orderNumbers}<br>
                  <strong>Unique Assignees:</strong> ${stats.assignees}<br>
                  <strong>Unique Statuses:</strong> ${Array.from(stats.statuses).join(', ')}<br>
                  <strong>Columns found:</strong> ${columns.join(', ')}<br>
                  <strong>Sample row:</strong><br>
                  <pre>${JSON.stringify(sample, null, 2)}</pre>
                `;
              } else {
                debugContent.innerHTML = '<em>No data loaded</em>';
              }
            }

            // Drag and Drop functionality for Validator Tool
            document.addEventListener('DOMContentLoaded', () => {
                const uploadArea = document.getElementById('uploadAreaValidator');
                const fileInput = document.getElementById('fileUpload');
                const fileNameDisplay = document.getElementById('fileNameDisplay');
                const csvInput = document.getElementById('csvInput'); // Reference to the CSV input

                if (uploadArea && fileInput && fileNameDisplay && csvInput) {
                    // Prevent default drag behaviors
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, preventDefaults, false);
                        document.body.addEventListener(eventName, preventDefaults, false); // For preventing outside drop
                    });

                    // Highlight drop zone when item is dragged over
                    ['dragenter', 'dragover'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, () => uploadArea.classList.add('drag-over'), false);
                    });

                    ['dragleave', 'drop'].forEach(eventName => {
                        uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('drag-over'), false);
                    });

                    // Handle dropped files
                    uploadArea.addEventListener('drop', handleDrop, false);

                    // Handle file selection via input click
                    fileInput.addEventListener('change', handleFileSelect, false);

                    function preventDefaults(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    function handleDrop(e) {
                        const dt = e.dataTransfer;
                        const files = dt.files;
                        if (files.length > 0) {
                            fileInput.files = files; // Assign the dropped files to the input
                            updateFileNameDisplay(files[0].name);
                        }
                    }

                    function handleFileSelect(e) {
                        const files = e.target.files;
                        if (files.length > 0) {
                            updateFileNameDisplay(files[0].name);
                        } else {
                            updateFileNameDisplay('');
                        }
                    }

                    function updateFileNameDisplay(name) {
                        if (name) {
                            fileNameDisplay.textContent = `File selected: "${name}". Click 'Analyze Data' to process.`;
                            csvInput.value = ''; // Clear manual input if a file is selected
                        } else {
                            fileNameDisplay.textContent = '';
                        }
                    }

                    // Clear file input display when manual input is typed into
                    csvInput.addEventListener('input', () => {
                        if (csvInput.value.trim() !== '') {
                            fileInput.value = ''; // Clear selected file
                            updateFileNameDisplay('');
                        }
                    });
                }
            });

        </script>
    </div>

    <script>
        // Store references to all theme toggle buttons
        const allDarkModeToggles = [];

        // Global loader functions
        function showStartupLoader(show, message = 'Loading...', progress = 0) {
            const loaderDiv = document.getElementById('startupLoader');
            const loaderText = document.getElementById('loaderText');
            const loaderProgressFill = document.getElementById('loaderProgressFill');

            if (show) {
                loaderDiv.style.display = 'flex';
                loaderDiv.style.opacity = '1';
                loaderText.textContent = message;
                loaderProgressFill.style.width = `${progress}%`;
            } else {
                loaderDiv.style.opacity = '0';
                setTimeout(() => {
                    loaderDiv.style.display = 'none';
                    loaderProgressFill.style.width = '0%'; // Reset progress for next time
                }, 300); // Allow fade out transition
            }
        }

        // Modified showTool to incorporate loader
        function launchToolWithLoader(toolName) {
            showStartupLoader(true, 'Launching...', 10);
            document.getElementById('startupOptions').style.display = 'none';

            // Simulate loading progress
            let progress = 10;
            const interval = setInterval(() => {
                progress += 20;
                if (progress <= 100) {
                    showStartupLoader(true, `Loading ${toolName} tool...`, progress);
                }
                if (progress >= 100) {
                    clearInterval(interval);
                    showStartupLoader(false); // Hide loader quickly after full progress

                    // Actual tool display logic
                    const summaryTool = document.getElementById('summaryTool');
                    const validationTool = document.getElementById('validationTool');
                    
                    summaryTool.style.display = 'none';
                    validationTool.style.display = 'none';

                    if (toolName === 'summary') {
                        summaryTool.style.display = 'block';
                        resetSummaryTool(); // Reset tool state when opening
                    } else if (toolName === 'validation') {
                        validationTool.style.display = 'block';
                        if (typeof initWorker === 'function' && !worker) {
                            initWorker();
                        }
                        resetTool(); // Reset tool state when opening
                    }

                    // Ensure the correct toggle button is visible based on the active tool
                    allDarkModeToggles.forEach(toggle => {
                        const parentTool = toggle.closest('.tool-container') || toggle.closest('.nav-buttons-container');
                        if (parentTool && ((toolName === 'summary' && parentTool.id === 'summaryTool') ||
                                        (toolName === 'validation' && parentTool.id === 'validationTool') ||
                                        (toolName === 'options' && parentTool.id === 'startupOptions'))) {
                            toggle.style.display = 'block';
                        } else {
                            toggle.style.display = 'none';
                        }
                    });

                    // For summary tool, it will now default to showing top performers if data is present.
                    if (toolName === 'summary' && allSummaryData.length > 0) {
                        hideAllSummaryOutputs(); // Clear previous displays
                        document.getElementById('summaryTopPerformers').style.display = 'block'; // Show top performers
                        renderSummaryTopPerformers();
                        document.getElementById('summaryControls').style.display = 'block'; // Ensure controls are visible
                    }
                }
            }, 100); // Update progress every 100ms
        }

        function initializeDarkModeToggles() {
            // Add the startup screen toggle
            const startupToggle = document.getElementById('globalDarkModeToggle');
            if (startupToggle) {
                allDarkModeToggles.push(startupToggle);
            }

            // Add the summary tool toggle
            const summaryToggle = document.getElementById('summaryDarkModeToggle');
            if (summaryToggle) {
                allDarkModeToggles.push(summaryToggle);
            }

            // Add the validator tool toggle
            const validatorToggle = document.getElementById('validatorDarkModeToggle');
            if (validatorToggle) {
                allDarkModeToggles.push(validatorToggle);
            }

            // Attach event listener to all toggles
            allDarkModeToggles.forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', newTheme);
                    localStorage.setItem('theme', newTheme);

                    // Update text for all toggles
                    updateDarkModeToggleText(newTheme);

                    // Re-render charts to apply new theme colors if in summary tool
                    if (document.getElementById('summaryTool').style.display === 'block' && allSummaryData.length > 0) {
                        // Check which summary output is currently visible and re-render only that one
                        if (document.getElementById('summaryOutput').style.display === 'block') {
                            const nameInput = document.getElementById('summaryNameInput');
                            if (nameInput.value.trim() !== '') {
                                generateSummaryReport(nameInput.value.trim());
                            } else {
                                // Re-render general charts if they were showing (shouldn't be, but as a fallback)
                                // If needed, you'd re-calculate overall status/type counts and call renderSummaryCharts
                            }
                        } else if (document.getElementById('summaryTrendCharts').style.display === 'block') {
                            renderSummaryTrendCharts();
                            renderPeakPerformanceAnalysis();
                        } else if (document.getElementById('summaryTopPerformers').style.display === 'block') {
                             renderSummaryTopPerformers();
                        }
                    }
                });
            });
        }

        function updateDarkModeToggleText(theme) {
            allDarkModeToggles.forEach(toggle => {
                toggle.textContent = theme === 'dark' ? '☀️ Light Mode' : '🌙 Dark Mode';
            });
        }

        // Original showTool function, now renamed to be called after loader
        function showTool(toolName) {
            // This function is now primarily called internally by launchToolWithLoader
            // It sets the visibility of the tools directly without the loader sequence.
            const summaryTool = document.getElementById('summaryTool');
            const validationTool = document.getElementById('validationTool');
            
            summaryTool.style.display = 'none';
            validationTool.style.display = 'none';

            if (toolName === 'summary') {
                summaryTool.style.display = 'block';
            } else if (toolName === 'validation') {
                validationTool.style.display = 'block';
                if (typeof initWorker === 'function' && !worker) {
                    initWorker();
                }
            }

            // Ensure the correct toggle button is visible based on the active tool
            allDarkModeToggles.forEach(toggle => {
                const parentTool = toggle.closest('.tool-container') || toggle.closest('.nav-buttons-container');
                if (parentTool && ((toolName === 'summary' && parentTool.id === 'summaryTool') ||
                                   (toolName === 'validation' && parentTool.id === 'validationTool') ||
                                   (toolName === 'options' && parentTool.id === 'startupOptions'))) {
                    toggle.style.display = 'block';
                } else {
                    toggle.style.display = 'none';
                }
            });
        }

        function showOptions() {
            document.getElementById('startupOptions').style.display = 'flex';
            document.getElementById('summaryTool').style.display = 'none';
            document.getElementById('validationTool').style.display = 'none';
            resetSummaryTool();
            resetTool();
            // Ensure only the startup toggle is visible
            allDarkModeToggles.forEach(toggle => {
                if (toggle.closest('.nav-buttons-container') && toggle.closest('.nav-buttons-container').id === 'startupOptions') {
                    toggle.style.display = 'block';
                } else {
                    toggle.style.display = 'none';
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Initial call to set up toggles and event listeners
            initializeDarkModeToggles();

            // Set initial theme from localStorage or system preference
            const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateDarkModeToggleText(savedTheme);

            // Show initial options screen
            showOptions();
        });
    </script>
</body>
</html>
